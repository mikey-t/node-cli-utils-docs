"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.color = exports.yellow = exports.purple = exports.gray = exports.cyan = exports.green = exports.red = exports.AnsiColor = exports.trace = exports.log = exports.possibleTaskFileNames = exports.traceEnabled = void 0;
var path = __importStar(require("node:path"));
var node_fs_1 = __importDefault(require("node:fs"));
var node_url_1 = require("node:url");
exports.traceEnabled = false;
var showMode = true; // In the startup message, display whether the ESM or CommonJS version of this script is being run
exports.possibleTaskFileNames = ['swigfile.cjs', 'swigfile.mjs', 'swigfile.js', 'swigfile.ts'];
var CliParam = /** @class */ (function () {
    function CliParam(value, isCommand) {
        var _this = this;
        this.matches = function (commandDescriptor) {
            return _this.value === commandDescriptor.id;
        };
        this.value = value;
        this.isCommand = isCommand;
    }
    return CliParam;
}());
var Swig = /** @class */ (function () {
    function Swig() {
        this.isCommonJS = typeof require === "function" && typeof module === "object" && module.exports;
        this.isEsm = !this.isCommonJS;
        this.versionString = '0.0.14'; // Set in build script in transpiled version of file
        this.cwd = process.cwd();
        this.seriesCounter = 1;
        this.parallelCounter = 1;
        this.listCommand = { id: 'list', names: ['list', 'ls', 'l'], alternateNames: ['-l', '--list'], description: 'List available tasks (default)', example: 'swig list' };
        this.helpCommand = { id: 'help', names: ['help', 'h'], alternateNames: ['-h', '--help'], description: 'Show help message', example: 'swig help' };
        this.versionCommand = { id: 'version', names: ['version', 'v'], alternateNames: ['-v', '--version'], description: 'Print version number', example: 'swig version' };
        this.filterCommand = { id: 'filter', names: ['filter', 'f'], alternateNames: ['-f', '--filter'], description: 'Filter and list tasks by name', example: 'swig filter pattern' };
        this.commandDescriptors = [
            { id: 'task', names: ['<taskName>'], alternateNames: [], description: 'Run a "task", which is an async function exported from your swigfile', example: 'swig taskName' },
            this.listCommand,
            this.helpCommand,
            this.versionCommand,
            this.filterCommand
        ];
    }
    // Get an instance with singletonManager.ts and then run this method to start the CLI.
    Swig.prototype.runMainAsync = function () {
        return __awaiter(this, void 0, void 0, function () {
            var err_1;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        return [4 /*yield*/, this.main()];
                    case 1:
                        _a.sent();
                        this.okExit();
                        return [3 /*break*/, 3];
                    case 2:
                        err_1 = _a.sent();
                        console.error(err_1);
                        this.failureExit('An unexpected error occurred');
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/];
                }
            });
        });
    };
    // Don't call directly - see exports in src/index.ts. Also see TaskOrNamedTask for more info.
    Swig.prototype.series = function (first) {
        var _this = this;
        var rest = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            rest[_i - 1] = arguments[_i];
        }
        var innerSeries = function () { return __awaiter(_this, void 0, void 0, function () {
            var _i, _a, task;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _i = 0, _a = __spreadArray([first], rest, true);
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        task = _a[_i];
                        return [4 /*yield*/, this.runTask(this.getLogNameAndTask(task))];
                    case 2:
                        _b.sent();
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4: return [2 /*return*/];
                }
            });
        }); };
        return innerSeries;
    };
    // Don't call directly - see exports in src/index.ts. Also see TaskOrNamedTask for more info.
    Swig.prototype.parallel = function () {
        var _this = this;
        var tasks = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            tasks[_i] = arguments[_i];
        }
        var innerParallel = function () { return __awaiter(_this, void 0, void 0, function () {
            var promises, results, rejected, errors;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        promises = tasks.map(function (task) {
                            return _this.runTask(_this.getLogNameAndTask(task));
                        });
                        return [4 /*yield*/, Promise.allSettled(promises)];
                    case 1:
                        results = _a.sent();
                        rejected = results.filter(function (result) { return result.status === 'rejected'; });
                        if (rejected.length > 0) {
                            errors = rejected.map(function (result) { return result.reason; });
                            throw errors;
                        }
                        return [2 /*return*/];
                }
            });
        }); };
        return innerParallel;
    };
    Swig.prototype.runTask = function (logNameAndTask) {
        return __awaiter(this, void 0, void 0, function () {
            var startTimestamp, endTimestamp, duration;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        startTimestamp = Date.now();
                        this.logFormattedStartMessage(logNameAndTask.logName, startTimestamp);
                        return [4 /*yield*/, logNameAndTask.task()];
                    case 1:
                        _a.sent();
                        endTimestamp = Date.now();
                        duration = endTimestamp - startTimestamp;
                        this.logFormattedEndMessage(logNameAndTask.logName, endTimestamp, duration);
                        return [2 /*return*/];
                }
            });
        });
    };
    Swig.prototype.getLogNameAndTask = function (taskOrNamedTask) {
        if (Array.isArray(taskOrNamedTask)) {
            return { logName: taskOrNamedTask[0], task: taskOrNamedTask[1] };
        }
        else {
            var name_1 = taskOrNamedTask.name;
            if (name_1 === 'innerSeries') {
                name_1 = "nested_series_".concat(this.seriesCounter.toString());
                this.seriesCounter++;
            }
            else if (name_1 === 'innerParallel') {
                name_1 = "nested_parallel_".concat(this.parallelCounter.toString());
                this.parallelCounter++;
            }
            else if (!name_1) {
                name_1 = 'anonymous';
            }
            return { logName: name_1, task: taskOrNamedTask };
        }
    };
    Swig.prototype.getTimestampPrefix = function (date) {
        var hours = String(date.getHours()).padStart(2, '0');
        var minutes = String(date.getMinutes()).padStart(2, '0');
        var seconds = String(date.getSeconds()).padStart(2, '0');
        var milliseconds = String(date.getMilliseconds()).padStart(3, '0');
        return (0, exports.gray)("[".concat(hours, ":").concat(minutes, ":").concat(seconds, ".").concat(milliseconds, "]"));
    };
    Swig.prototype.logFormattedStartMessage = function (taskName, startTimestamp) {
        var prefix = "".concat(this.getTimestampPrefix(new Date(startTimestamp)), " ");
        log("".concat(prefix, "Starting \uD83D\uDE80 ").concat((0, exports.cyan)(taskName)));
    };
    Swig.prototype.logFormattedEndMessage = function (taskName, endTimestamp, duration) {
        var prefix = "".concat(this.getTimestampPrefix(new Date(endTimestamp)), " ");
        log("".concat(prefix, "Finished \u2705 ").concat((0, exports.cyan)(taskName), " after ").concat((0, exports.purple)(this.formatElapsedDuration(duration))));
    };
    Swig.prototype.formatElapsedDuration = function (elapsedMs) {
        if (elapsedMs < 1000) {
            return "".concat(elapsedMs, " ms");
        }
        else {
            return "".concat((elapsedMs / 1000).toFixed(2), " seconds");
        }
    };
    Swig.prototype.getTaskFilePath = function () {
        for (var _i = 0, possibleTaskFileNames_1 = exports.possibleTaskFileNames; _i < possibleTaskFileNames_1.length; _i++) {
            var filename = possibleTaskFileNames_1[_i];
            var filePath = path.resolve(this.cwd, filename);
            if (node_fs_1.default.existsSync(filePath)) {
                if (this.isEsm) {
                    return (0, node_url_1.pathToFileURL)(filePath);
                }
                return filePath;
            }
        }
        return null;
    };
    Swig.prototype.getStartMessage = function (taskFilePath, cliParam) {
        var commandOrTaskMessage = cliParam.isCommand ? 'Command' : 'Task';
        var helpMessage = "".concat((0, exports.gray)('use '), "swig help ").concat((0, exports.gray)('for more info'));
        var taskFilename = taskFilePath ? path.basename(taskFilePath) : '';
        var modeMessage = "[ Mode: ".concat((0, exports.cyan)(this.isEsm ? 'ESM' : 'CommonJS'), " ]");
        var versionMessage = "Version: ".concat((0, exports.cyan)(this.versionString));
        return "[ ".concat(commandOrTaskMessage, ": ").concat((0, exports.cyan)(cliParam.value), " ][ Swigfile: ").concat((0, exports.cyan)(taskFilename), " ][ ").concat(versionMessage, " ]").concat(showMode ? modeMessage : '', "[ ").concat(helpMessage, " ]");
    };
    Swig.prototype.getFinishedMessage = function (mainStartTime, hasErrors) {
        var totalDuration = Date.now() - mainStartTime;
        var statusMessage = "Result: ".concat(hasErrors ? (0, exports.red)('failed') : (0, exports.green)('success'));
        var durationMessage = "Total duration: ".concat((0, exports.color)(this.formatElapsedDuration(totalDuration), hasErrors ? AnsiColor.YELLOW : AnsiColor.GREEN));
        return "[ ".concat(statusMessage, " ][ ").concat(durationMessage, " ]");
    };
    Swig.prototype.getCliParam = function () {
        var cliArg = process.argv[2];
        if (!cliArg) {
            return new CliParam(this.listCommand.id, true);
        }
        var commandDescriptor = this.commandDescriptors.find(function (d) { return d.names.includes(cliArg.toLowerCase()) || d.alternateNames.includes(cliArg.toLowerCase()); });
        if (commandDescriptor) {
            return new CliParam(commandDescriptor.id, true);
        }
        var argWithInvalidFunctionCharsStripped = cliArg.replace(/[^a-zA-Z0-9_]/g, '');
        if (argWithInvalidFunctionCharsStripped !== cliArg) {
            this.failureExit("Invalid task name: ".concat(cliArg));
        }
        return new CliParam(cliArg, false);
    };
    Swig.prototype.isFunction = function (task) {
        return !!task && typeof task === 'function';
    };
    Swig.prototype.showTaskList = function (tasks, mainStartTime, filter) {
        var _a;
        var taskNames = tasks.map(function (_a) {
            var name = _a[0];
            return name;
        });
        log("Available tasks:");
        var _loop_1 = function (taskName) {
            var taskFn = (_a = tasks.find(function (_a) {
                var name = _a[0];
                return name === taskName;
            })) === null || _a === void 0 ? void 0 : _a[1];
            if (this_1.isFunction(taskFn)) {
                if (filter && !taskName.toLowerCase().includes(filter.toLowerCase())) {
                    return "continue";
                }
                log("  ".concat((0, exports.cyan)(taskName)));
            }
        };
        var this_1 = this;
        for (var _i = 0, taskNames_1 = taskNames; _i < taskNames_1.length; _i++) {
            var taskName = taskNames_1[_i];
            _loop_1(taskName);
        }
        log(this.getFinishedMessage(mainStartTime));
        return this.okExit();
    };
    Swig.prototype.showHelpMessage = function () {
        log("Usage: swig <command or taskName> [options]");
        log("Commands:");
        for (var _i = 0, _a = this.commandDescriptors; _i < _a.length; _i++) {
            var commandDescriptor = _a[_i];
            log("  ".concat(commandDescriptor.names.join(', ')).concat((0, exports.gray)(" - ".concat(commandDescriptor.description))));
            log("    ".concat((0, exports.gray)(commandDescriptor.example)));
        }
        return this.okExit();
    };
    Swig.prototype.showVersionMessage = function () {
        log(this.versionString);
        return this.okExit();
    };
    Swig.prototype.getFuncByTaskName = function (tasks, taskName) {
        var _a;
        return (_a = tasks.find(function (_a) {
            var name = _a[0];
            return name === taskName;
        })) === null || _a === void 0 ? void 0 : _a[1];
    };
    Swig.prototype.main = function () {
        return __awaiter(this, void 0, void 0, function () {
            var mainStartTime, cliParam, taskFilePathOrUrl, module, tasks, err_2, filter, rootFunc, hasErrors, rawErr_1, label, err;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        mainStartTime = Date.now();
                        cliParam = this.getCliParam();
                        taskFilePathOrUrl = this.getTaskFilePath() // string or URL to support both ESM and CJS
                        ;
                        if (cliParam.value === this.versionCommand.id) {
                            return [2 /*return*/, this.showVersionMessage()];
                        }
                        log(this.getStartMessage(taskFilePathOrUrl ? taskFilePathOrUrl.toString() : '', cliParam));
                        if (cliParam.value === this.helpCommand.id) {
                            return [2 /*return*/, this.showHelpMessage()];
                        }
                        if (!taskFilePathOrUrl) {
                            return [2 /*return*/, this.failureExit("Task file not found - must be one of the following: ".concat(exports.possibleTaskFileNames.join(', ')))];
                        }
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, Promise.resolve("".concat(taskFilePathOrUrl.toString())).then(function (s) { return __importStar(require(s)); })];
                    case 2:
                        module = _a.sent();
                        tasks = Object.entries(module).filter(function (_a) {
                            var value = _a[1];
                            return _this.isFunction(value);
                        });
                        return [3 /*break*/, 4];
                    case 3:
                        err_2 = _a.sent();
                        if (taskFilePathOrUrl.toString().endsWith('.ts') && err_2 instanceof Error && err_2.message.includes('exports is not defined')) {
                            console.log("".concat((0, exports.yellow)('Suggestion:'), " try adjusting your tsconfig.json compilerOptions (especially the \"module\" setting)"));
                        }
                        console.error(err_2);
                        return [2 /*return*/, this.failureExit("Could not import task file ".concat(taskFilePathOrUrl))];
                    case 4:
                        if (cliParam.matches(this.listCommand)) {
                            return [2 /*return*/, this.showTaskList(tasks, mainStartTime)];
                        }
                        if (cliParam.matches(this.filterCommand)) {
                            filter = process.argv[3];
                            return [2 /*return*/, this.showTaskList(tasks, mainStartTime, filter)];
                        }
                        rootFunc = this.getFuncByTaskName(tasks, cliParam.value);
                        if (!rootFunc) {
                            return [2 /*return*/, this.failureExit("Task '".concat(cliParam.value, "' not found. Tasks must be exported functions in your swigfile. Try 'swig list' to see available tasks."))];
                        }
                        hasErrors = false;
                        _a.label = 5;
                    case 5:
                        _a.trys.push([5, 7, 8, 9]);
                        return [4 /*yield*/, rootFunc()];
                    case 6:
                        _a.sent();
                        return [3 /*break*/, 9];
                    case 7:
                        rawErr_1 = _a.sent();
                        hasErrors = true;
                        label = 'Error';
                        err = rawErr_1;
                        if (Array.isArray(err)) {
                            if (err.length === 1) {
                                err = err[0];
                            }
                            else if (err.length > 1) {
                                label = "Errors (".concat(err.length, ")");
                            }
                        }
                        log((0, exports.red)(label));
                        console.error(err);
                        return [3 /*break*/, 9];
                    case 8:
                        log(this.getFinishedMessage(mainStartTime, hasErrors));
                        if (hasErrors) {
                            this.failureExit();
                        }
                        return [7 /*endfinally*/];
                    case 9: return [2 /*return*/];
                }
            });
        });
    };
    Swig.prototype.failureExit = function (message) {
        if (message) {
            console.error("".concat((0, exports.red)('Error:'), " ").concat(message));
        }
        process.exit(1);
    };
    Swig.prototype.okExit = function () {
        process.exit(0);
    };
    return Swig;
}());
exports.default = Swig;
function log(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    console.log.apply(console, __spreadArray([message], optionalParams, false));
}
exports.log = log;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function trace(message) {
    var optionalParams = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        optionalParams[_i - 1] = arguments[_i];
    }
    if (exports.traceEnabled) {
        console.log.apply(console, __spreadArray([message], optionalParams, false));
    }
}
exports.trace = trace;
var AnsiColor;
(function (AnsiColor) {
    AnsiColor["RESET"] = "\u001B[0m";
    AnsiColor["RED"] = "\u001B[31m";
    AnsiColor["GREEN"] = "\u001B[32m";
    AnsiColor["YELLOW"] = "\u001B[33m";
    AnsiColor["CYAN"] = "\u001B[96m";
    AnsiColor["GRAY"] = "\u001B[90m";
    AnsiColor["PURPLE"] = "\u001B[35m";
})(AnsiColor || (exports.AnsiColor = AnsiColor = {}));
var Colors = /** @class */ (function () {
    function Colors() {
    }
    Colors.getInstance = function () {
        if (!Colors.instance) {
            Colors.instance = new Colors();
        }
        return Colors.instance;
    };
    Colors.prototype.color = function (str, colorAnsiCode) {
        return "".concat(colorAnsiCode).concat(str).concat(AnsiColor.RESET);
    };
    return Colors;
}());
var singletonColors = Colors.getInstance();
var red = function (str) { return singletonColors.color(str, AnsiColor.RED); };
exports.red = red;
var green = function (str) { return singletonColors.color(str, AnsiColor.GREEN); };
exports.green = green;
var cyan = function (str) { return singletonColors.color(str, AnsiColor.CYAN); };
exports.cyan = cyan;
var gray = function (str) { return singletonColors.color(str, AnsiColor.GRAY); };
exports.gray = gray;
var purple = function (str) { return singletonColors.color(str, AnsiColor.PURPLE); };
exports.purple = purple;
var yellow = function (str) { return singletonColors.color(str, AnsiColor.YELLOW); };
exports.yellow = yellow;
var color = function (str, color) { return singletonColors.color(str, color); };
exports.color = color;
//# sourceMappingURL=Swig.cjs.map