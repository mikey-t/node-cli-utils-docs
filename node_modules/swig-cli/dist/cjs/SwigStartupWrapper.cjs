#!/usr/bin/env node
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var node_fs_1 = __importDefault(require("node:fs"));
var node_path_1 = __importDefault(require("node:path"));
var Swig_js_1 = __importStar(require("./Swig.cjs"));
var node_child_process_1 = require("node:child_process");
var SwigStartupWrapper = /** @class */ (function () {
    function SwigStartupWrapper() {
        this.swigfilePath = '';
        this.swigfileName = '';
        this.packageJsonType = 'commonjs';
        this.swigfileExtension = 'js';
        this.hasTsx = false;
    }
    SwigStartupWrapper.prototype.main = function () {
        (0, Swig_js_1.trace)('- SwigStartupWrapper is checking a few things...');
        var hasSwigfile = this.populateSwigfile();
        if (hasSwigfile) {
            (0, Swig_js_1.trace)("- swigfile: ".concat(this.swigfilePath));
            (0, Swig_js_1.trace)("- swigfile extension: ".concat(this.swigfileExtension));
        }
        this.populatePackageJsonTypeOrThrow();
        (0, Swig_js_1.trace)("- package.json type: ".concat(this.packageJsonType));
        if (hasSwigfile) {
            this.warnIfPossibleSwigfileSyntaxMismatch();
        }
        else {
            (0, Swig_js_1.trace)("- swigfile not found - skipping syntax check");
        }
        return this.spawnSwig();
    };
    SwigStartupWrapper.prototype.spawnSwig = function () {
        return __awaiter(this, void 0, void 0, function () {
            var preservedArgs, isTypescript, swigScriptEsm, swigScriptCjs, tsNodeBinCjs, tsNodeBinEsm, swigScript, tsNodeBin, command, spawnArgs;
            return __generator(this, function (_a) {
                preservedArgs = process.argv.slice(2);
                isTypescript = this.swigfileExtension === 'ts';
                swigScriptEsm = './node_modules/swig-cli/dist/esm/swigCli.cjs';
                swigScriptCjs = './node_modules/swig-cli/dist/cjs/swigCli.cjs';
                tsNodeBinCjs = './node_modules/ts-node/dist/bin.cjs';
                tsNodeBinEsm = './node_modules/ts-node/dist/bin-esm.cjs';
                swigScript = swigScriptEsm;
                tsNodeBin = tsNodeBinEsm;
                if (isTypescript && this.packageJsonType === 'esm') {
                    swigScript = swigScriptEsm;
                    tsNodeBin = tsNodeBinEsm;
                }
                else if (isTypescript && this.packageJsonType === 'commonjs') {
                    swigScript = swigScriptCjs;
                    tsNodeBin = tsNodeBinCjs;
                }
                if (isTypescript && !this.hasTsx && !node_fs_1.default.existsSync(tsNodeBin)) {
                    this.exitWithError("typescript detected but a dev dependency is missing.\nChoose and install either ts-node or tsx using 'npm i -D ts-node' or 'npm i -D tsx' (note that tsx esm functionality is experimental).");
                }
                command = 'node';
                spawnArgs = __spreadArray([swigScript], preservedArgs, true);
                if (isTypescript && this.hasTsx) {
                    spawnArgs = __spreadArray(['--no-warnings', '--loader', 'tsx'], spawnArgs, true);
                }
                else if (isTypescript) {
                    spawnArgs = __spreadArray([tsNodeBin, '-T', swigScript], preservedArgs, true);
                }
                (0, Swig_js_1.trace)("- swig-cli spawn command: ".concat(command, " ").concat(spawnArgs.join(' ')));
                return [2 /*return*/, this.spawnSwigCliAsync(command, spawnArgs)];
            });
        });
    };
    SwigStartupWrapper.prototype.populateSwigfile = function () {
        var swigfilePath;
        for (var _i = 0, possibleTaskFileNames_1 = Swig_js_1.possibleTaskFileNames; _i < possibleTaskFileNames_1.length; _i++) {
            var filename = possibleTaskFileNames_1[_i];
            swigfilePath = "./".concat(filename);
            if (node_fs_1.default.existsSync(swigfilePath)) {
                this.swigfilePath = swigfilePath;
                this.swigfileName = node_path_1.default.basename(this.swigfilePath);
                this.swigfileExtension = this.swigfileName.split('.')[1];
                return true;
            }
        }
        return false;
    };
    SwigStartupWrapper.prototype.populatePackageJsonTypeOrThrow = function () {
        var packageJsonPath = './package.json';
        if (!node_fs_1.default.existsSync(packageJsonPath)) {
            this.exitWithError('no package.json found - cannot detect project type');
        }
        var packageJsonContents = node_fs_1.default.readFileSync(packageJsonPath, { encoding: 'utf-8' });
        var packageJson = JSON.parse(packageJsonContents);
        this.packageJsonType = packageJson.type && packageJson.type.toLowerCase() === 'module' ? 'esm' : 'commonjs';
        // Check that swig-cli is installed as a dependency or devDependency
        if ((packageJson.devDependencies && packageJson.devDependencies['swig-cli']) || (packageJson.dependencies && packageJson.dependencies['swig-cli'])) {
            (0, Swig_js_1.trace)('- swig-cli is installed as a dependency in the project');
        }
        else {
            this.exitWithError("swig-cli was not found in the project dependencies or devDependencies - install with: npm i -D swig-cli");
        }
        if ((packageJson.devDependencies && packageJson.devDependencies['tsx']) || (packageJson.dependencies && packageJson.dependencies['tsx'])) {
            this.hasTsx = true;
            (0, Swig_js_1.trace)('- tsx is installed as a dependency in the project');
        }
    };
    SwigStartupWrapper.prototype.warnIfPossibleSwigfileSyntaxMismatch = function () {
        var swigfileContents = node_fs_1.default.readFileSync(this.swigfilePath, { encoding: 'utf-8' });
        if (swigfileContents.trim() === '')
            return;
        if (!swigfileContents) {
            throw new Error("Error parsing swigfile ".concat(this.swigfilePath));
        }
        var swigfileContentsWithoutComments = this.stripComments(swigfileContents);
        var hasEsmSyntax = this.fileStringHasEsm(swigfileContentsWithoutComments);
        var hasCommonJsSyntax = this.fileStringHasCommonJs(swigfileContentsWithoutComments);
        var hasBoth = hasEsmSyntax && hasCommonJsSyntax;
        // Don't warn - it might just be a new project with nothing exported or imported yet
        if (!hasEsmSyntax && !hasCommonJsSyntax)
            return;
        // Typescript allows both cjs and esm syntax, even mixed - as long as the package.json type is commonjs
        if (this.swigfileExtension === 'ts' && this.packageJsonType === 'commonjs')
            return;
        if (this.swigfileExtension === 'ts' && this.packageJsonType === 'esm' && (hasBoth || hasCommonJsSyntax)) {
            this.logWarning("".concat(this.swigfileName, " needs to use only ESM syntax if the package.json type is set to \"module\"."));
            this.logOptionsMatrix();
            return;
        }
        if (hasBoth) {
            this.logWarning("".concat(this.swigfileName, " appears to have both ESM and CommonJS syntax, but it should have only one or the other."));
            this.logOptionsMatrix();
            return;
        }
        if (this.swigfileExtension === 'mjs' && hasEsmSyntax && !hasCommonJsSyntax)
            return;
        if (this.swigfileExtension === 'cjs' && !hasEsmSyntax && hasCommonJsSyntax)
            return;
        if (this.swigfileExtension === 'js' && this.packageJsonType === 'esm' && hasEsmSyntax)
            return;
        if (this.swigfileExtension === 'js' && this.packageJsonType === 'commonjs' && hasCommonJsSyntax)
            return;
        if (this.swigfileExtension === 'ts' && this.packageJsonType === 'commonjs')
            return;
        if (this.swigfileExtension === 'ts' && this.packageJsonType === 'esm' && hasEsmSyntax)
            return;
        this.logWarning("".concat(this.swigfileExtension, " appears to use ").concat(hasEsmSyntax ? 'ESM' : 'CommonJS', " syntax and your package.json type is set to ").concat(this.packageJsonType, "."));
        this.logOptionsMatrix();
    };
    SwigStartupWrapper.prototype.fileStringHasEsm = function (fileContent) {
        var esmPatterns = [
            /^\s*import\s+\w+\s+from\s+['"].+['"]/m,
            /^\s*import\s*\{[^}]+\}\s+from\s+['"].+['"]/m,
            /^\s*export\s+const\s+\w+/m,
            /^\s*export\s+default\s+\w+/m,
            /^\s*export\s+function\s+\w+/m,
            /^\s*export\s+class\s+\w+/m // export class x
        ];
        return esmPatterns.some(function (pattern) { return pattern.test(fileContent); });
    };
    SwigStartupWrapper.prototype.fileStringHasCommonJs = function (fileContent) {
        var commonJsPatterns = [
            /^\s*const\s+\w+\s+=\s+require\(['"].+['"]\)/m,
            /^\s*module\.exports\s+=/m,
            /^\s*exports\.\w+\s+=/m // exports.x =
        ];
        return commonJsPatterns.some(function (pattern) { return pattern.test(fileContent); });
    };
    SwigStartupWrapper.prototype.stripComments = function (content) {
        return content.replace(/\/\/.*$|\/\*[\s\S]*?\*\/|([^\\:]|^)\/\/.*$/gm, '');
    };
    SwigStartupWrapper.prototype.logWarning = function (str) {
        (0, Swig_js_1.log)("\n".concat((0, Swig_js_1.yellow)('[swig-cli] Warning:'), " ").concat(str));
    };
    SwigStartupWrapper.prototype.exitWithError = function (message) {
        (0, Swig_js_1.log)("".concat((0, Swig_js_1.red)('[swig-cli] Error:'), " ").concat(message));
        process.exit(1);
    };
    SwigStartupWrapper.prototype.logOptionsMatrix = function () {
        var optionsData = [
            ['swigfile', 'package.json type', 'syntax', 'notes'],
            ['.cjs', 'any', 'CommonJS', ''],
            ['.mjs', 'any', 'ESM', ''],
            ['.cjs', 'module', 'ESM', ''],
            ['.cjs', 'commonjs', 'CommonJS', ''],
            ['.ts', 'module', 'ESM', 'can be affected by tsconfig.json settings'],
            ['.ts', 'commonjs', 'CommonJS and/or ESM', 'can be affected by tsconfig.json settings']
        ];
        (0, Swig_js_1.log)('\nAvailable configurations:\n');
        this.logTable(optionsData);
        (0, Swig_js_1.log)('');
    };
    SwigStartupWrapper.prototype.logTable = function (data) {
        if (data.length === 0 || data[0].length === 0)
            return;
        var numColumns = data[0].length;
        var columnWidths = [];
        var _loop_1 = function (i) {
            columnWidths[i] = Math.max.apply(Math, data.map(function (row) { var _a; return ((_a = row[i]) === null || _a === void 0 ? void 0 : _a.length) || 0; }));
        };
        for (var i = 0; i < numColumns; i++) {
            _loop_1(i);
        }
        var lineSeparator = ' ' + columnWidths.map(function (width) { return '-'.repeat(width); }).join(' + ');
        for (var i = 0; i < data.length; i++) {
            var paddedRowArray = data[i].map(function (cell, colIdx) { return cell.padEnd(columnWidths[colIdx], ' '); });
            (0, Swig_js_1.log)(' ' + paddedRowArray.join(' | '));
            if (i === 0)
                (0, Swig_js_1.log)(lineSeparator);
        }
    };
    SwigStartupWrapper.prototype.spawnSwigCliAsync = function (command, args) {
        return new Promise(function (resolve) {
            var result = { code: 1 };
            var prefix = "[spawnSwigCliAsync] ";
            var child = (0, node_child_process_1.spawn)(command, args, { stdio: 'inherit' });
            var childId = child.pid;
            if (!childId) {
                throw new Error("".concat(prefix, "Error spawning ChildProcess"));
            }
            var exitListener = function (code) {
                child.kill();
                child.unref();
                result.code = code;
                resolve(result);
            };
            process.on('exit', exitListener);
            var signals = ['SIGINT', 'SIGTERM', 'SIGQUIT'];
            var signalListener = function (signal) {
                (0, Swig_js_1.trace)("".concat(prefix, "Process received ").concat(signal, " - killing ChildProcess with ID ").concat(childId));
                child.kill(signal);
            };
            signals.forEach(function (signal) {
                process.on(signal, signalListener);
            });
            child.on('exit', function (code, signal) {
                (0, Swig_js_1.trace)("".concat(prefix, "ChildProcess exited with code ").concat(code, " and signal ").concat(signal));
                result.code = code !== null && code !== void 0 ? code : 1;
                process.removeListener('exit', exitListener);
                signals.forEach(function (signal) {
                    process.removeListener(signal, signalListener);
                });
                child.removeAllListeners();
                resolve(result);
            });
            child.on('error', function (error) {
                (0, Swig_js_1.trace)("".concat(prefix, "ChildProcess emitted an error event: "), error);
            });
        });
    };
    return SwigStartupWrapper;
}());
exports.default = SwigStartupWrapper;
var firstArg = process.argv.slice(2)[0];
if (['h', 'help', '-h', '--help', 'v', 'version', '-v', '--version'].includes(firstArg)) {
    // If first arg is version or help, skip all checks and go straight to
    // calling Swig since all it needs to do is print some text and exit.
    (0, Swig_js_1.trace)("- SwigStartupWrapper is skipping checks because the command is ".concat(firstArg));
    new Swig_js_1.default().runMainAsync();
}
else {
    new SwigStartupWrapper().main()
        .then(function (result) {
        if (result.error) {
            console.error(result.error);
        }
        process.exit(result.code);
    }).catch(function (err) {
        console.error(err);
        process.exit(42);
    });
}
//# sourceMappingURL=SwigStartupWrapper.cjs.map