import fs from 'node:fs';
import path from 'node:path';
import { ExtendedError, mkdirp, requireString, requireValidPath, spawnAsync, trace, whichSync } from './generalUtils.js';
import { config } from './NodeCliUtilsConfig.js';
/**
 * This utility class exists so we can mock the `which` dependency in unit tests without resorting to libraries that hack the import system.
 */
export class TarballUtility {
    whichSyncFn;
    spawnAsyncFn;
    statSyncFn;
    mkdirpFn;
    constructor(dependencies = {}) {
        this.whichSyncFn = dependencies.whichSyncFn ?? whichSync;
        this.spawnAsyncFn = dependencies.spawnAsyncFn ?? spawnAsync;
        this.statSyncFn = dependencies.statSyncFn ?? fs.statSync;
        this.mkdirpFn = dependencies.mkdirpFn ?? mkdirp;
    }
    /**
     * Creates a gzipped tarball from a directory by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
     * Note that Windows has tar since Windows 10 1803 (see https://devblogs.microsoft.com/commandline/windows10v1803/.
     *
     * It's possible this isn't 100% reliable due to differences in `tar` versions across platforms. If better normalization
     * is required, consider using the npm package `node-tar` instead.
     * @param directoryToTarball The directory to tarball. The directory name will be used as the root directory in the tarball
     * @param tarballPath The path to the tarball to create - must end with '.tar.gz'
     * @param options See {@link CreateTarballOptions}
     */
    createTarball = async (directoryToTarball, tarballPath, options) => {
        requireValidPath('directoryToTarball', directoryToTarball);
        requireString('tarballPath', tarballPath);
        const defaultOptions = { excludes: [] };
        const mergedOptions = { ...defaultOptions, ...options };
        if (!this.whichSyncFn('tar').location) {
            throw new Error('tar command not found - please install tar on your OS to use this method, or consider using the npm package node-tar instead');
        }
        if (tarballPath.endsWith('.tar.gz') === false) {
            throw new Error(`tarballPath must end with '.tar.gz': ${tarballPath}`);
        }
        const directoryToTarballParentDir = path.dirname(directoryToTarball);
        const directoryToTarballName = path.basename(directoryToTarball);
        const outputDirectory = path.dirname(tarballPath);
        if (!fs.existsSync(outputDirectory)) {
            trace(`tarballPath directory does not exist - creating '${outputDirectory}'`);
            await this.mkdirpFn(outputDirectory);
        }
        else if (fs.existsSync(tarballPath)) {
            throw new Error(`tarballPath already exists - delete, move or rename it first: ${tarballPath}`);
        }
        const excludesArgs = mergedOptions.excludes.length > 0 ? mergedOptions.excludes.map(exclude => `--exclude=${exclude}`) : [];
        const verboseFlag = config.traceEnabled ? ['-v'] : [];
        const args = [...(verboseFlag), '-czf', tarballPath, '-C', directoryToTarballParentDir, ...excludesArgs, directoryToTarballName];
        const result = await this.spawnAsyncFn('tar', args);
        if (result.code !== 0) {
            throw new Error(`tar command failed with code ${result.code}`);
        }
        trace('tarball created: ' + tarballPath);
    };
    /**
     * Unpacks a gzipped tarball by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
     * This method will throw an error if the unpackDirectory is not empty, unless the `throwOnNonEmptyUnpackDir` option is set to false.
     * @param tarballPath The path to the tarball to unpack
     * @param unpackDirectory The directory to unpack the tarball into
     * @param options The options to use when unpacking the tarball. See {@link TarballUnpackOptions}.
     */
    unpackTarball = async (tarballPath, unpackDirectory, options) => {
        requireValidPath('tarballPath', tarballPath);
        requireString('unpackDirectory', unpackDirectory);
        if (!this.whichSyncFn('tar').location) {
            throw new Error('tar command not found - please install tar on your OS to use this method, or consider using the npm package node-tar instead');
        }
        const defaultOptions = { createDirIfNotExists: false, stripComponents: 0, throwOnNonEmptyUnpackDir: true };
        const mergedOptions = { ...defaultOptions, ...options };
        if (mergedOptions.stripComponents < 0) {
            throw new Error('stripComponents must be greater than or equal to 0 if provided');
        }
        const unpackedDirExists = fs.existsSync(unpackDirectory);
        if (unpackedDirExists && !this.isDirectory(unpackDirectory)) {
            throw new Error(`unpackDirectory exists but is not a directory: ${unpackDirectory}`);
        }
        if (mergedOptions.createDirIfNotExists && !unpackedDirExists) {
            await this.tryCreateDirectory(unpackDirectory);
        }
        if (!mergedOptions.createDirIfNotExists && !unpackedDirExists) {
            throw new Error(`unpackDirectory does not exist: ${unpackDirectory}`);
        }
        if (mergedOptions.throwOnNonEmptyUnpackDir && this.dirIsNotEmpty(unpackDirectory)) {
            throw new Error(`unpackDirectory exists but is not empty: ${unpackDirectory}`);
        }
        const verboseFlag = config.traceEnabled ? ['-v'] : [];
        const args = [...(verboseFlag), '-xzf', tarballPath, '-C', unpackDirectory, '--strip-components', mergedOptions.stripComponents.toString()];
        const result = await this.spawnAsyncFn('tar', args);
        if (result.code !== 0) {
            throw new Error(`tar command failed with code ${result.code}`);
        }
        trace(`tarball unpacked at ${unpackDirectory}`);
    };
    /**
     * A more opinionated version of {@link unpackTarball} that assumes you want to create the directory and strip the first directory out of the unpacked files.
     * @param tarballPath The path to the tarball to unpack
     * @param unpackDirectory The directory to unpack the tarball into - will be created if it doesn't exist and will throw if it exists but is not empty
     * @param stripComponents The number of leading directories to strip out of the unpacked files, defaults to 1
     */
    unpackTarballContents = async (tarballPath, unpackDirectory, stripComponents = 1) => {
        await this.unpackTarball(tarballPath, unpackDirectory, { stripComponents, createDirIfNotExists: true });
    };
    isDirectory = (path) => {
        try {
            const stats = this.statSyncFn(path);
            return stats.isDirectory();
        }
        catch (err) {
            trace('error checking idDirectory (returning false)', err);
            return false;
        }
    };
    dirIsNotEmpty = (dirPath) => {
        try {
            const stats = this.statSyncFn(dirPath);
            return stats.isDirectory() && fs.readdirSync(dirPath).length > 0;
        }
        catch (err) {
            throw new ExtendedError('Error checking dirIsNotEmpty - see innerError', err);
        }
    };
    tryCreateDirectory = async (dirPath) => {
        try {
            await this.mkdirpFn(dirPath);
        }
        catch (err) {
            throw new ExtendedError('Error creating unpackDirectory - see innerError', err);
        }
    };
}
const defaultUtil = new TarballUtility();
export const createTarball = defaultUtil.createTarball;
export const unpackTarball = defaultUtil.unpackTarball;
export const unpackTarballContents = defaultUtil.unpackTarballContents;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFyYmFsbFV0aWxpdHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvVGFyYmFsbFV0aWxpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sU0FBUyxDQUFBO0FBQ3hCLE9BQU8sSUFBSSxNQUFNLFdBQVcsQ0FBQTtBQUM1QixPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQUUsZ0JBQWdCLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBRSxTQUFTLEVBQUUsTUFBTSxtQkFBbUIsQ0FBQTtBQUN4SCxPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0seUJBQXlCLENBQUE7QUF1QmhEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLGNBQWM7SUFDakIsV0FBVyxDQUFrQjtJQUM3QixZQUFZLENBQW1CO0lBQy9CLFVBQVUsQ0FBb0I7SUFDOUIsUUFBUSxDQUFlO0lBRS9CLFlBQVksZUFBb0QsRUFBRTtRQUNoRSxJQUFJLENBQUMsV0FBVyxHQUFHLFlBQVksQ0FBQyxXQUFXLElBQUksU0FBUyxDQUFBO1FBQ3hELElBQUksQ0FBQyxZQUFZLEdBQUcsWUFBWSxDQUFDLFlBQVksSUFBSSxVQUFVLENBQUE7UUFDM0QsSUFBSSxDQUFDLFVBQVUsR0FBRyxZQUFZLENBQUMsVUFBVSxJQUFJLEVBQUUsQ0FBQyxRQUFRLENBQUE7UUFDeEQsSUFBSSxDQUFDLFFBQVEsR0FBRyxZQUFZLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQTtJQUNqRCxDQUFDO0lBRUQ7Ozs7Ozs7OztPQVNHO0lBQ0gsYUFBYSxHQUFHLEtBQUssRUFBRSxrQkFBMEIsRUFBRSxXQUFtQixFQUFFLE9BQThCLEVBQUUsRUFBRTtRQUN4RyxnQkFBZ0IsQ0FBQyxvQkFBb0IsRUFBRSxrQkFBa0IsQ0FBQyxDQUFBO1FBQzFELGFBQWEsQ0FBQyxhQUFhLEVBQUUsV0FBVyxDQUFDLENBQUE7UUFFekMsTUFBTSxjQUFjLEdBQUcsRUFBRSxRQUFRLEVBQUUsRUFBRSxFQUFFLENBQUE7UUFDdkMsTUFBTSxhQUFhLEdBQUcsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFBO1FBRXZELElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLFFBQVEsRUFBRTtZQUNyQyxNQUFNLElBQUksS0FBSyxDQUFDLDhIQUE4SCxDQUFDLENBQUE7U0FDaEo7UUFFRCxJQUFJLFdBQVcsQ0FBQyxRQUFRLENBQUMsU0FBUyxDQUFDLEtBQUssS0FBSyxFQUFFO1lBQzdDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLFdBQVcsRUFBRSxDQUFDLENBQUE7U0FDdkU7UUFFRCxNQUFNLDJCQUEyQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtRQUNwRSxNQUFNLHNCQUFzQixHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsa0JBQWtCLENBQUMsQ0FBQTtRQUVoRSxNQUFNLGVBQWUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxDQUFBO1FBRWpELElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ25DLEtBQUssQ0FBQyxvREFBb0QsZUFBZSxHQUFHLENBQUMsQ0FBQTtZQUM3RSxNQUFNLElBQUksQ0FBQyxRQUFRLENBQUMsZUFBZSxDQUFDLENBQUE7U0FDckM7YUFBTSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxpRUFBaUUsV0FBVyxFQUFFLENBQUMsQ0FBQTtTQUNoRztRQUVELE1BQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsYUFBYSxDQUFDLFFBQVEsQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUUsQ0FBQyxhQUFhLE9BQU8sRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQTtRQUMzSCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7UUFDckQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsMkJBQTJCLEVBQUUsR0FBRyxZQUFZLEVBQUUsc0JBQXNCLENBQUMsQ0FBQTtRQUVoSSxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBRW5ELElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7U0FDL0Q7UUFFRCxLQUFLLENBQUMsbUJBQW1CLEdBQUcsV0FBVyxDQUFDLENBQUE7SUFDMUMsQ0FBQyxDQUFBO0lBRUQ7Ozs7OztPQU1HO0lBQ0gsYUFBYSxHQUFHLEtBQUssRUFBRSxXQUFtQixFQUFFLGVBQXVCLEVBQUUsT0FBdUMsRUFBRSxFQUFFO1FBQzlHLGdCQUFnQixDQUFDLGFBQWEsRUFBRSxXQUFXLENBQUMsQ0FBQTtRQUM1QyxhQUFhLENBQUMsaUJBQWlCLEVBQUUsZUFBZSxDQUFDLENBQUE7UUFFakQsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsS0FBSyxDQUFDLENBQUMsUUFBUSxFQUFFO1lBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsOEhBQThILENBQUMsQ0FBQTtTQUNoSjtRQUVELE1BQU0sY0FBYyxHQUFHLEVBQUUsb0JBQW9CLEVBQUUsS0FBSyxFQUFFLGVBQWUsRUFBRSxDQUFDLEVBQUUsd0JBQXdCLEVBQUUsSUFBSSxFQUFFLENBQUE7UUFDMUcsTUFBTSxhQUFhLEdBQUcsRUFBRSxHQUFHLGNBQWMsRUFBRSxHQUFHLE9BQU8sRUFBRSxDQUFBO1FBRXZELElBQUksYUFBYSxDQUFDLGVBQWUsR0FBRyxDQUFDLEVBQUU7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FBQyxnRUFBZ0UsQ0FBQyxDQUFBO1NBQ2xGO1FBRUQsTUFBTSxpQkFBaUIsR0FBRyxFQUFFLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxDQUFBO1FBRXhELElBQUksaUJBQWlCLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQzNELE1BQU0sSUFBSSxLQUFLLENBQUMsa0RBQWtELGVBQWUsRUFBRSxDQUFDLENBQUE7U0FDckY7UUFFRCxJQUFJLGFBQWEsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzVELE1BQU0sSUFBSSxDQUFDLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxDQUFBO1NBQy9DO1FBRUQsSUFBSSxDQUFDLGFBQWEsQ0FBQyxvQkFBb0IsSUFBSSxDQUFDLGlCQUFpQixFQUFFO1lBQzdELE1BQU0sSUFBSSxLQUFLLENBQUMsbUNBQW1DLGVBQWUsRUFBRSxDQUFDLENBQUE7U0FDdEU7UUFFRCxJQUFJLGFBQWEsQ0FBQyx3QkFBd0IsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1lBQ2pGLE1BQU0sSUFBSSxLQUFLLENBQUMsNENBQTRDLGVBQWUsRUFBRSxDQUFDLENBQUE7U0FDL0U7UUFFRCxNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUE7UUFDckQsTUFBTSxJQUFJLEdBQUcsQ0FBQyxHQUFHLENBQUMsV0FBVyxDQUFDLEVBQUUsTUFBTSxFQUFFLFdBQVcsRUFBRSxJQUFJLEVBQUUsZUFBZSxFQUFFLG9CQUFvQixFQUFFLGFBQWEsQ0FBQyxlQUFlLENBQUMsUUFBUSxFQUFFLENBQUMsQ0FBQTtRQUMzSSxNQUFNLE1BQU0sR0FBRyxNQUFNLElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFBO1FBRW5ELElBQUksTUFBTSxDQUFDLElBQUksS0FBSyxDQUFDLEVBQUU7WUFDckIsTUFBTSxJQUFJLEtBQUssQ0FBQyxnQ0FBZ0MsTUFBTSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUE7U0FDL0Q7UUFFRCxLQUFLLENBQUMsdUJBQXVCLGVBQWUsRUFBRSxDQUFDLENBQUE7SUFDakQsQ0FBQyxDQUFBO0lBRUQ7Ozs7O09BS0c7SUFDSCxxQkFBcUIsR0FBRyxLQUFLLEVBQUUsV0FBbUIsRUFBRSxlQUF1QixFQUFFLGtCQUEwQixDQUFDLEVBQUUsRUFBRTtRQUMxRyxNQUFNLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxFQUFFLGVBQWUsRUFBRSxFQUFFLGVBQWUsRUFBRSxvQkFBb0IsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFBO0lBQ3pHLENBQUMsQ0FBQTtJQUVPLFdBQVcsR0FBRyxDQUFDLElBQVksRUFBVyxFQUFFO1FBQzlDLElBQUk7WUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxDQUFBO1lBQ25DLE9BQU8sS0FBSyxDQUFDLFdBQVcsRUFBRSxDQUFBO1NBQzNCO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixLQUFLLENBQUMsOENBQThDLEVBQUUsR0FBRyxDQUFDLENBQUE7WUFDMUQsT0FBTyxLQUFLLENBQUE7U0FDYjtJQUNILENBQUMsQ0FBQTtJQUVPLGFBQWEsR0FBRyxDQUFDLE9BQWUsRUFBVyxFQUFFO1FBQ25ELElBQUk7WUFDRixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1lBQ3RDLE9BQU8sS0FBSyxDQUFDLFdBQVcsRUFBRSxJQUFJLEVBQUUsQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsQ0FBQTtTQUNqRTtRQUFDLE9BQU8sR0FBRyxFQUFFO1lBQ1osTUFBTSxJQUFJLGFBQWEsQ0FBQywrQ0FBK0MsRUFBRSxHQUFZLENBQUMsQ0FBQTtTQUN2RjtJQUNILENBQUMsQ0FBQTtJQUVPLGtCQUFrQixHQUFHLEtBQUssRUFBRSxPQUFlLEVBQUUsRUFBRTtRQUNyRCxJQUFJO1lBQ0YsTUFBTSxJQUFJLENBQUMsUUFBUSxDQUFDLE9BQU8sQ0FBQyxDQUFBO1NBQzdCO1FBQUMsT0FBTyxHQUFHLEVBQUU7WUFDWixNQUFNLElBQUksYUFBYSxDQUFDLGlEQUFpRCxFQUFFLEdBQVksQ0FBQyxDQUFBO1NBQ3pGO0lBQ0gsQ0FBQyxDQUFBO0NBQ0Y7QUFFRCxNQUFNLFdBQVcsR0FBRyxJQUFJLGNBQWMsRUFBRSxDQUFBO0FBRXhDLE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFBO0FBQ3RELE1BQU0sQ0FBQyxNQUFNLGFBQWEsR0FBRyxXQUFXLENBQUMsYUFBYSxDQUFBO0FBQ3RELE1BQU0sQ0FBQyxNQUFNLHFCQUFxQixHQUFHLFdBQVcsQ0FBQyxxQkFBcUIsQ0FBQSJ9