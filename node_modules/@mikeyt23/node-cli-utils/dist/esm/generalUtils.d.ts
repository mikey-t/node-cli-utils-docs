/// <reference types="node" resolution-mode="require"/>
import { SpawnOptions } from 'node:child_process';
/**
 * Just a wrapper for console.log() to type less.
 * @param data The data to log
 * @param moreData More data to log
 */
export declare function log(data: unknown, ...moreData: unknown[]): void;
/**
 * Log conditionally. Useful for methods that have an option to either suppress output or to show it when it normally isn't.
 * @param data The data to log
 * @param moreData More data to log
 */
export declare function logIf(shouldLog: boolean, data: unknown, ...moreData: unknown[]): void;
/**
 * Wrapper for console.log() that is suppressed if NodeCliUtilsConfig.logEnabled is false.
 * @param data The data to log
 * @param moreData More data to log
 */
export declare function trace(data?: unknown, ...moreData: unknown[]): void;
/**
 * Type guard for a string keyed dictionary.
 */
export type StringKeyedDictionary = {
    [name: string]: string;
};
/**
 * Options for the {@link spawnAsync} wrapper function for NodeJS spawn.
 */
export interface SpawnResult {
    /**
     * The exit code of the spawned process. Rather than allowing null, this will be set to 1 if the process exits with null, or 0 if user cancels with ctrl+c.
     */
    code: number;
    /**
     * The stdout of the spawned process. **Warning:** this will be empty by default without changing SpawnOptions stdio (see {@link spawnAsync}).
     */
    stdout: string;
    /**
     * The stderr of the spawned process. **Warning:** this will be empty by default without changing SpawnOptions stdio (see {@link spawnAsync}).
     */
    stderr: string;
    /**
     * Not an error from the child process stderr, but rather an error thrown when attempting to spawn the child process.
     */
    error?: Error;
    /**
     * The current working directory of the spawned process. Not changed by method, so just repeating your SpawnOptions.cwd back to you, but helpful for debugging.
     */
    cwd?: string;
}
/**
 * Error throw by {@link spawnAsync} when the spawned process exits with a non-zero exit code and options.throwOnNonZero is true.
 *
 * Contains a {@link SpawnResult} with the exit code, stdout, stderr, and error (if any).
 */
export declare class SpawnError extends Error {
    result: SpawnResult;
    constructor(message: string, result: SpawnResult);
}
/**
 * Spawn result for calls to {@link simpleSpawnSync} and {@link simpleCmdSync}.
 *
 * Contains the same properties as {@link SpawnResult} plus stdoutLines, which is stdout split into lines from stdout that weren't empty.
 */
export interface SimpleSpawnResult extends SpawnResult {
    stdoutLines: string[];
}
/**
 * Error throw by {@link simpleSpawnSync} and {@link simpleCmdSync} when the spawned process exits with a non-zero exit code and throwOnNonZero param is true (the default).
 *
 * Contains a {@link SimpleSpawnResult} with the exit code, stdout, stderr, and error (if any) in addition to stdoutLines, which is stdout split into lines from stdout that weren't empty.
 */
export declare class SimpleSpawnError extends Error {
    result: SimpleSpawnResult;
    constructor(message: string, result: SimpleSpawnResult);
}
/**
 * The result type for {@link whichSync}. Contains the location of the command, any additional locations, and an error if one occurred.
 */
export interface WhichResult {
    location: string | undefined;
    additionalLocations: string[] | undefined;
    error: Error | undefined;
}
/**
 * Type guard for command passed to {@link spawnDockerCompose}.
 */
export type DockerComposeCommand = 'build' | 'config' | 'cp' | 'create' | 'down' | 'events' | 'exec' | 'images' | 'kill' | 'logs' | 'ls' | 'pause' | 'port' | 'ps' | 'pull' | 'push' | 'restart' | 'rm' | 'run' | 'start' | 'stop' | 'top' | 'unpause' | 'up' | 'version';
/**
 * Sleeps for the specified number of milliseconds.
 * @param ms The number of milliseconds to sleep
 * @returns A Promise that resolves after the specified number of milliseconds
 */
export declare function sleep(ms: number): Promise<void>;
/**
 * An extension of the built-in SpawnOptions with an extra option to specify whether a non-zero exit code should throw an error.
 */
export interface SpawnOptionsWithThrow extends SpawnOptions {
    throwOnNonZero: boolean;
    simpleErrorMsg?: string;
}
/**
 * This is a wrapper function for NodeJS spawn. Defaults stdio to inherit so that output is visible in the console,
 * but note that this means stdout and stderr will not be available in the returned SpawnResult. To hide the output
 * from the console but collect the stdout and stderr in the SpawnResult, use stdio: 'pipe'.
 *
 * When spawning long-running processes, use {@link spawnAsyncLongRunning} instead so that unexpected
 * termination of the parent process will not orphan the child process tree on windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param options The options to pass to the command
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
export declare function spawnAsync(command: string, args?: string[], options?: Partial<SpawnOptionsWithThrow>): Promise<SpawnResult>;
/**
 * Use this alternate spawn wrapper instead of {@link spawnAsync} when spawning long-running processes to
 * avoid orphaned child process trees on Windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param cwd The current working directory to run the command from - defaults to process.cwd()
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
export declare function spawnAsyncLongRunning(command: string, args?: string[], cwd?: string): Promise<SpawnResult>;
/**
 * Ensure the directory exists. Similar to `mkdir -p` (creates parent directories if they don't exist).
 * @param dir The directory to ensure exists. If it does not exist, it will be created.
 */
export declare function ensureDirectory(dir: string): Promise<void>;
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
export declare function mkdirp(dir: string): Promise<void>;
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
export declare function mkdirpSync(dir: string): Promise<void>;
export interface EmptyDirectoryOptions {
    /** An optional array of file and directory names to skip, but only at the top level of the directoryToEmpty. */
    fileAndDirectoryNamesToSkip: string[];
    force: boolean;
    throwIfNotExists: boolean;
}
/**
 * Empties a directory of all files and subdirectories. Optionally skips files and directories at the top level. For other
 * options, see {@link EmptyDirectoryOptions}.
 * @param directoryToEmpty The directory to empty.
 * @param options See {@link EmptyDirectoryOptions}.
 */
export declare function emptyDirectory(directoryToEmpty: string, options?: Partial<EmptyDirectoryOptions>): Promise<void>;
/**
 * Copies the contents of a directory to another directory (not including the top-level directory itself).
 *
 * If the destination directory does not exist, it will be created.
 * @param sourceDirectory Directory to copy from
 * @param destinationDirectory Directory to copy to
 */
export declare function copyDirectoryContents(sourceDirectory: string, destinationDirectory: string): Promise<void>;
/**
 * Helper method to validate that a non-falsy and non-empty value is provided for a parameter that should be a string.
 * @param paramName The name of the parameter to be used in the error message
 * @param paramValue The value of the parameter
 */
export declare function requireString(paramName: string, paramValue: string): void;
/**
 * Helper method to validate that the path actually exists for the provided value.
 * @param paramName The name of the parameter, for logging purposes
 * @param paramValue The value of the parameter
 */
export declare function requireValidPath(paramName: string, paramValue: string): void;
/**
 * Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit.
 *
 * See https://docs.docker.com/compose/environment-variables/envvars/#compose_project_name.
 * @param projectName The string to validate
 * @returns `true` if it's a valid docker compose project name and `false` otherwise
 */
export declare function isDockerComposeProjectNameValid(projectName: string): boolean;
/**
 * Options for {@link spawnDockerCompose}.
 * @param projectName
 * Note that there are other better options such as using the environment variable `COMPOSE_PROJECT_NAME`. See https://docs.docker.com/compose/environment-variables/envvars/#compose_project_name.
 * @param attached Default: false. All commands that support the detached option wil use it unless attached is specified as true (-d support: exec, logs, ps, restart, run, start, stop, up)
 * @param useDockerComposeFileDirectoryAsCwd Default: false. If true, the docker compose command will be run in the directory containing the docker compose file.
 */
export interface DockerComposeOptions {
    /** Additional arguments to pass to the docker-compose command. */
    args: string[];
    /**
     * Defaults to `false`. Controls whether or not the `--detach` option is passed. Note that this only applies to
     * some commands (exec, logs, ps, restart, run, start, stop, up).
     */
    attached: boolean;
    /**
    * If not provided, it will default to using the directory that the docker-compose.yml is located in.
    * Specifies what current working directory to use with the spawn command.
    *
    * **Important:**: this only affects the current working directory of the spawned process itself. The docker command will still only pull in env values from a `.env`
    * file in the same directory as the docker-compose.yml, NOT the cwd passed here. If a different `.env` file path is needed, use the {@link altEnvFilePath} option. If
    * you use the {@link altEnvFilePath} option with a relative path, ensure that it is relative to the current working directory passed with this option.
    */
    cwd?: string;
    /**
     * Optional. If provided, projectName will be passed as the `--project-name` param to `docker compose` so that generated containers will use it as a prefix
     * instead of the default, which is the directory name where the docker-compose.yml is located.
     *
     * Alternate approaches for setting the docker compose project name:
     *
     * - Locate your docker-compose.yml file in the root of your project so that docker will use that directory name for prefixing generated containers
     * - OR, locate your docker-compose.yml in a sub-directory named appropriately for use as a prefix for generated containers
     * - OR, put a `.env` file in the same directory as your docker-compose.yml
     * with the entry `COMPOSE_PROJECT_NAME=your-project-name`
     *
     * Additional note on docker compose project names form the official docker compose docs: "Project names must contain only lowercase letters, decimal digits,
     * dashes, and underscores, and must begin with a lowercase letter or decimal digit". See https://docs.docker.com/compose/environment-variables/envvars/#compose_project_name.
     *
     */
    projectName?: string;
    /**
     * Optional. If provided, profile is passed to docker compose along with `--profile` param. Must match this regex: `[a-zA-Z0-9][a-zA-Z0-9_.-]+`.
     *
     * See https://docs.docker.com/compose/profiles/.
     */
    profile?: string;
    /**
     * The option `useWslPrefix` set to `true` can be used If Docker Desktop is not installed on Windows and docker commands need to execute via wsl.
     */
    useWslPrefix?: boolean;
    /**
     * Specify an alternative env file. This is useful since docker will normally only use a `.env` file in the same directory as the docker-compose.yml file,
     * regardless of the current working directory of the running command. This path will be passed to docker compose using the `--env-file` option.
     *
     * **Important:** if using a relative path, be sure pass the appropriate value for {@link cwd} to this method so that the relative path can correctly be resolved.
     */
    altEnvFilePath?: string;
}
/**
 * For docker compose commands, see https://docs.docker.com/compose/reference/. For available options for this wrapper function, see {@link DockerComposeOptions}.
 *
 * The current working directory will be the directory of the {@link dockerComposePath} unless specified in the options. This ensures relative paths in the
 * docker compose file will be relative to itself by default.
 *
 * See {@link DockerComposeOptions.projectName} for info on where to locate your docker compose file and how to specify the docker project name.
 * @param dockerComposePath Path to docker-compose.yml
 * @param dockerComposeCommand The docker-compose command to run
 * @param options {@link DockerComposeOptions} to use, including additional arguments to pass to the docker compose command and the project name
 */
export declare function spawnDockerCompose(dockerComposePath: string, dockerComposeCommand: DockerComposeCommand, options?: Partial<DockerComposeOptions>): Promise<void>;
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Does not return empty lines. Also see {@link stringToLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
export declare function stringToNonEmptyLines(str: string): string[];
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Returns empty lines. Also see {@link stringToNonEmptyLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
export declare function stringToLines(str: string): string[];
/**
 * Runs the requested command using NodeJS spawnSync wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export declare function simpleCmdSync(command: string, args?: string[], throwOnNonZero?: boolean): SimpleSpawnResult;
/**
 * Runs the requested command using {@link spawnAsync} wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnAsync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export declare function simpleCmdAsync(command: string, args?: string[], throwOnNonZero?: boolean): Promise<SimpleSpawnResult>;
/**
 * Runs the requested command using NodeJS spawnSync and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export declare function simpleSpawnSync(command: string, args?: string[], throwOnNonZero?: boolean): SimpleSpawnResult;
/**
 * Runs the requested command using {@link spawnAsync} and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export declare function simpleSpawnAsync(command: string, args?: string[], throwOnNonZero?: boolean): Promise<SimpleSpawnResult>;
/**
 * @returns `true` if platform() is 'win32', `false` otherwise
 */
export declare function isPlatformWindows(): boolean;
/**
 *
 * @returns `true` if platform() is 'darwin', `false` otherwise
 */
export declare function isPlatformMac(): boolean;
/**
 *
 * @returns `true` if {@link isPlatformWindows} and {@link isPlatformMac} are both `false, otherwise returns `true`
 */
export declare function isPlatformLinux(): boolean;
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
export declare function which(commandName: string): Promise<WhichResult>;
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
export declare function whichSync(commandName: string): WhichResult;
/**
 * Uses {@link which} to determine if docker is installed. If the `which` call doesn't find docker and the platform
 * is Windows, then this will check the output of `wsl docker --version` to see if just the engine is installed.
 * @returns `true` if docker is installed, `false` otherwise
 */
export declare function isDockerInstalled(): Promise<boolean>;
/**
 * Runs the `docker info` command and looks for "error during connect" in the output to determine if docker is running. If you
 * want to check if docker is installed, use {@link isDockerInstalled}.
 * @returns `true` if docker is installed and running, `false` otherwise
 */
export declare function isDockerRunning(): Promise<boolean>;
/**
 * Attempt to start the docker service if it isn't running. Whether it's running is determined by a call to {@link isDockerRunning}.
 *
 * Notes on docker startup command:
 * - May require entering a password
 * - On Windows with Docker Desktop it will run `Start-Process "C:\Program Files\Docker\Docker\Docker Desktop.exe"`
 * - On Windows without Docker Desktop it will run `wsl -u root -e sh -c "service docker start"`
 * - On Linux it will run `sudo systemctl start docker`
 * - Not currently supported on Mac
 *
 * @throws An {@link Error} If docker is not detected on the system.
 * @throws An {@link Error} if docker is detected as installed and not running but the system is not Windows or Linux.
 */
export declare function ensureDockerRunning(): Promise<void>;
/**
 * Uses built-in NodeJS readline to ask a question and return the user's answer.
 * @param query The question to ask
 * @returns A Promise that resolves to the user's answer
 */
export declare function askQuestion(query: string): Promise<string>;
/**
 * A simple CLI prompt using the built-in NodeJS readline functionality to ask for confirmation.
 * @param question The question to ask
 * @returns A Promise that resolves to true if the user answers 'y' or 'yes', false otherwise
 */
export declare function getConfirmation(question: string): Promise<boolean>;
/**
 * Example of using {@link getConfirmation}.
 */
export declare function getConfirmationExample(): Promise<void>;
/**
 * Copy entries from a source .env file to a destination .env file for which the destination .env file does not already have entries.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a .env.template file to a root .env file.
 *
 * For copying root .env files to other locations, use {@link overwriteEnvFile}.
 * @param sourcePath The path to the source .env file such as a `.env.template` file (use {@link overwriteEnvFile} for copying root .env files to other locations)
 * @param destinationPath The path to the destination .env file, such as the root .env file
 */
export declare function copyNewEnvValues(sourcePath: string, destinationPath: string): Promise<void>;
/**
 * Copy entries from a source .env file to a destination .env file, overwriting any existing entries in the destination .env file.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a root .env file to additional locations (server, client, docker-compose directory, etc.)
 * throughout your solution so you only have to manage one .env file.
 *
 * Note that this does not delete any existing entries in the destination .env file, which is useful if you have additional entries in
 * the destination .env file that you don't want to overwrite.
 *
 * For copying .env.template files to root .env files, use {@link copyNewEnvValues}.
 * @param sourcePath The path to the source .env file such as a root .env file (use {@link copyNewEnvValues} for .env.template files)
 * @param destinationPath The path to the destination .env file
 * @param suppressAddKeysMessages If true, messages about adding missing keys will not be logged (useful if you're always calling {@link copyModifiedEnv} after this call)
 */
export declare function overwriteEnvFile(sourcePath: string, destinationPath: string, suppressAddKeysMessages?: boolean): Promise<void>;
/**
 * Copy entries from a source .env file to a destination .env file, but only for the keys specified in keepKeys.
 * Will also modify entries in the destination .env file as specified in modifyEntries.
 * @param sourcePath The path to the source .env file
 * @param destinationPath The path to the destination .env file
 * @param keepKeys The keys to keep from the source .env file
 * @param modifyEntries The entries to modify in the destination .env file
 */
export declare function copyModifiedEnv(sourcePath: string, destinationPath: string, keepKeys: string[], modifyEntries?: StringKeyedDictionary): Promise<void>;
/**
 * Filters a dictionary by key.
 * @param dict The dictionary to filter
 * @param predicate A function that returns true if the key should be included in the filtered dictionary
 * @returns A new dictionary with only the keys that passed the predicate
 */
export declare function filterDictionary(dict: StringKeyedDictionary, predicate: (key: string) => boolean): StringKeyedDictionary;
/**
 * Sorts a dictionary by key in ascending order.
 * @param dict The dictionary to sort
 * @returns A new dictionary sorted by key in ascending order
 */
export declare function sortDictionaryByKeyAsc(dict: StringKeyedDictionary): StringKeyedDictionary;
/**
 * Helper method to delete a .env file if it exists.
 * @param envPath The path to the .env file to delete
 */
export declare function deleteEnvIfExists(envPath: string): Promise<void>;
export interface FindFilesOptions {
    maxDepth: number;
    excludeDirectoryNames: string[];
    returnForwardSlashRelativePaths: boolean;
}
/**
 * Searches a directory recursively for files that match the specified pattern.
 * The filenamePattern is a simple text string with asterisks (*) for wildcards.
 * @param dir The directory to find files in
 * @param filenamePattern The pattern to match files against
 * @param options Specify a max depth to search, defaults to 5
 * @returns A Promise that resolves to an array of file paths that match the pattern
 */
export declare function findFilesRecursively(dir: string, filenamePattern: string, options?: Partial<FindFilesOptions>): Promise<string[]>;
/** Utility function to escape a string for use within regex */
export declare function escapeStringForRegex(str: string): string;
/**
 * Logs the provided 2-dimensional string array as a formatted table.
 *
 * @param data 2-dimensional string array where the first row is the column headers
 * @example
 *
 * logTable([
 *   ['Name', 'Age', 'Country'],
 *   ['Alice', '28', 'USA'],
 *   ['Bob', '22', 'Canada']
 * ])
 */
export declare function logTable(data: string[][]): void;
/**
 * See {@link getPowershellHackArgs}.
 */
export declare const powershellHackPrefix = "$env:PSModulePath = [Environment]::GetEnvironmentVariable('PSModulePath', 'Machine'); ";
/**
 * Powershell doesn't load the system PSModulePath when running in a non-interactive shell.
 * This is a workaround to set the PSModulePath environment variable to the system value before running a powershell command.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The powershell command to run
 * @returns An array of arguments to pass to {@link spawnAsync} with the "powershell" command as the first argument
 */
export declare function getPowershellHackArgs(command: string): string[];
/**
 * Returns a humanized string representation of the number of milliseconds using ms, seconds, minutes, or hours.
 * @param milliseconds The number of milliseconds to humanize
 * @returns A humanized string representation of the number
 */
export declare function humanizeTime(milliseconds: number): string;
export declare class ExtendedError extends Error {
    innerError: Error | null;
    constructor(message: string, innerError?: Error);
}
export declare function getHostname(url: string): string;
export declare function isDirectory(path: string): Promise<boolean>;
export declare function isDirectorySync(path: string): boolean;
export type PlatformCode = 'win' | 'linux' | 'mac';
/**
 * This is a somewhat naive method but is useful if you rarely or never deal with unusual operating systems.
 * @returns `win`, `mac` or `linux`
 */
export declare function getPlatformCode(): PlatformCode;
/**
 * Tries connecting to a port to see if it's being listened on or not. It's likely that this won't work in a lot of scenarios, so use it at your own risk.
 * @param port The port to check
 * @returns `true` if the port is available, `false` otherwise
 */
export declare function isPortAvailable(port: number): Promise<boolean>;
/**
 * Returns the value for an environment variable or throws if it's undefined or null. Pass optional `throwOnEmpty` param to throw when the key exists but has an empty value.
 * @param varName The name of the environment variable to get.
 * @param throwOnEmpty Throw an error if key exists (not undefined or null) but is empty.
 * @returns
 */
export declare function getRequiredEnvVar(varName: string, throwOnEmpty?: boolean): string;
export declare function getNormalizedError(err: unknown): Error;
/** Options for {@link withRetryAsync}. */
export interface WithRetryOptions {
    /**
     * Number of milliseconds to wait before the first attempt.
     */
    initialDelayMilliseconds: number;
    /**
     * Use this in log messages instead of the function name (useful for passing lambdas which would otherwise display as "anonymous").
     */
    functionLabel?: string;
    /**
     * If NodeCliUtilsConfig.traceEnabled is `true` then messages will be logged even if this option is `false`.
     * Set to `true` to log messages even if Node ]
     */
    traceEnabled: boolean;
    /**
     * Log all errors rather than just the last one after all retries fail. If `true`, this setting overrides library trace and this method's traceEnabled option.
     */
    logIntermediateErrors: boolean;
}
/**
 * Call a function until it succeeds. Will stop after the number of calls specified by `maxCalls` param, or forever if -1 is passed.
 * @param func The function to call
 * @param maxCalls The maximum number of times to call the function before giving up. Pass -1 to retry forever.
 * @param delayMilliseconds The number of milliseconds to wait between calls
 * @param options Options for controlling the behavior of the retry. See {@link WithRetryOptions}.
 */
export declare function withRetryAsync(func: () => Promise<void>, maxCalls: number, delayMilliseconds: number, options?: Partial<WithRetryOptions>): Promise<void>;
/**
 * Collapses each instance of consecutive whitespace characters into a single space.
 */
export declare function collapseWhitespace(str: string): string;
/**
 * Check if a string is a valid directory name. This is a very simple check that just makes sure the string doesn't contain any invalid characters.
 * @param dirName The directory name to check
 * @returns `true` if the directory name is valid, `false` otherwise
 */
export declare function isValidDirName(dirName: string): boolean;
export declare function hasWhitespace(str: string): boolean;
export declare function stripShellMetaCharacters(input: string): string;
export declare enum Emoji {
    RightArrow = "\u27A1\uFE0F",
    LeftArrow = "\u2B05\uFE0F",
    GreenCheck = "\u2705",
    Warning = "\u26A0\uFE0F",
    Lightning = "\u26A1",
    Exclamation = "\u2757",
    RedQuestion = "\u2753",
    RedX = "\u274C",
    Info = "\u2139\uFE0F",
    SadFace = "\uD83D\uDE22",
    Tools = "\uD83D\uDEE0\uFE0F",
    NoEntry = "\u26D4",
    Stop = "\uD83D\uDED1",
    Certificate = "\uD83D\uDCDC",
    Key = "\uD83D\uDD11"
}
/**
 * Converts a windows path to a WSL path (Windows Subsystem for Linux) if it's an absolute path, otherwise returns it unchanged.
 *
 * Normally you can use `path.resolve()` to convert paths to whatever is appropriate for the OS, but if you're running on Windows and need to spawn a
 * command with `wsl yourCommand`, then you'll want to use this function to convert any parameters that are paths so that they can be resolved within WSL.
 * Because the intended use of this function is for passing params around, most use cases will also require paths with spaces or single quotes to be
 * wrapped in quotes, so `wrapInQuotesIfSpaces` defaults to true.
 * @param winPath The Windows path.
 * @param wrapInQuotesIfSpaces Defaults to `true`. If `true` and the `winPath` passed has spaces, the returned string will be wrapped in quotes.
 * Single quotes will be used unless there are single quote characters within the path, in which case it will be wrapped in double quotes.
 * @returns The wsl equivalent path.
 */
export declare function toWslPath(winPath: string, wrapInQuotesIfSpaces?: boolean): string;
//# sourceMappingURL=generalUtils.d.ts.map