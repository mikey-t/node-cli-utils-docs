import fs from 'node:fs';
import fsp from 'node:fs/promises';
import { platform } from 'node:os';
import path, { resolve } from 'node:path';
import * as readline from 'readline';
import * as net from 'net';
import { config } from './NodeCliUtilsConfig.js';
import { copyEnv, dictionaryToEnvFileString, getEnvAsDictionary, simpleSpawnAsyncInternal, simpleSpawnSyncInternal, spawnAsyncInternal, validateFindFilesRecursivelyParams, whichInternal } from './generalUtilsInternal.js';
const dockerComposeCommandsThatSupportDetached = ['exec', 'logs', 'ps', 'restart', 'run', 'start', 'stop', 'up'];
/**
 * Just a wrapper for console.log() to type less.
 * @param data The data to log
 * @param moreData More data to log
 */
export function log(data, ...moreData) {
    console.log(data, ...moreData);
}
/**
 * Log conditionally. Useful for methods that have an option to either suppress output or to show it when it normally isn't.
 * @param data The data to log
 * @param moreData More data to log
 */
export function logIf(shouldLog, data, ...moreData) {
    if (shouldLog) {
        console.log(data, ...moreData);
    }
}
/**
 * Wrapper for console.log() that is suppressed if NodeCliUtilsConfig.logEnabled is false.
 * @param data The data to log
 * @param moreData More data to log
 */
export function trace(data, ...moreData) {
    if (config.traceEnabled) {
        const prefix = `[TRACE]`;
        console.log(prefix, data, ...moreData);
    }
}
/**
 * Error throw by {@link spawnAsync} when the spawned process exits with a non-zero exit code and options.throwOnNonZero is true.
 *
 * Contains a {@link SpawnResult} with the exit code, stdout, stderr, and error (if any).
 */
export class SpawnError extends Error {
    result;
    constructor(message, result) {
        super(message);
        this.result = result;
    }
}
/**
 * Error throw by {@link simpleSpawnSync} and {@link simpleCmdSync} when the spawned process exits with a non-zero exit code and throwOnNonZero param is true (the default).
 *
 * Contains a {@link SimpleSpawnResult} with the exit code, stdout, stderr, and error (if any) in addition to stdoutLines, which is stdout split into lines from stdout that weren't empty.
 */
export class SimpleSpawnError extends Error {
    result;
    constructor(message, result) {
        super(message);
        this.result = result;
    }
}
/**
 * Sleeps for the specified number of milliseconds.
 * @param ms The number of milliseconds to sleep
 * @returns A Promise that resolves after the specified number of milliseconds
 */
export async function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
/**
 * This is a wrapper function for NodeJS spawn. Defaults stdio to inherit so that output is visible in the console,
 * but note that this means stdout and stderr will not be available in the returned SpawnResult. To hide the output
 * from the console but collect the stdout and stderr in the SpawnResult, use stdio: 'pipe'.
 *
 * When spawning long-running processes, use {@link spawnAsyncLongRunning} instead so that unexpected
 * termination of the parent process will not orphan the child process tree on windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param options The options to pass to the command
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
export async function spawnAsync(command, args, options) {
    return spawnAsyncInternal(command, args ?? [], options);
}
/**
 * Use this alternate spawn wrapper instead of {@link spawnAsync} when spawning long-running processes to
 * avoid orphaned child process trees on Windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param cwd The current working directory to run the command from - defaults to process.cwd()
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
export async function spawnAsyncLongRunning(command, args, cwd) {
    return spawnAsyncInternal(command, args ?? [], { cwd: cwd, isLongRunning: true });
}
/**
 * Ensure the directory exists. Similar to `mkdir -p` (creates parent directories if they don't exist).
 * @param dir The directory to ensure exists. If it does not exist, it will be created.
 */
export async function ensureDirectory(dir) {
    return await mkdirp(dir);
}
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
export async function mkdirp(dir) {
    requireString('dir', dir);
    try {
        await fsp.mkdir(dir, { recursive: true });
    }
    catch (err) {
        // Must catch and re-throw in order to get a stack trace: https://github.com/nodejs/node/issues/30944
        throw new ExtendedError('Error creating directory', getNormalizedError(err));
    }
}
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
export async function mkdirpSync(dir) {
    requireString('dir', dir);
    fs.mkdirSync(dir, { recursive: true });
}
/**
 * Empties a directory of all files and subdirectories. Optionally skips files and directories at the top level. For other
 * options, see {@link EmptyDirectoryOptions}.
 * @param directoryToEmpty The directory to empty.
 * @param options See {@link EmptyDirectoryOptions}.
 */
export async function emptyDirectory(directoryToEmpty, options) {
    requireString('directoryToEmpty', directoryToEmpty);
    const defaultOptions = { fileAndDirectoryNamesToSkip: [], force: false, throwIfNotExists: false };
    const mergedOptions = { ...defaultOptions, ...options };
    if (!fs.existsSync(directoryToEmpty)) {
        if (mergedOptions.throwIfNotExists) {
            throw new Error('Directory does not exist and throwIfNotExists was set to true');
        }
        trace(`directoryToEmpty does not exist - creating directory ${directoryToEmpty}`);
        await mkdirp(directoryToEmpty);
        return;
    }
    if (!fs.lstatSync(directoryToEmpty).isDirectory()) {
        throw new Error(`directoryToEmpty is not a directory: ${directoryToEmpty}`);
    }
    // Add some guardrails to prevent accidentally emptying the wrong directory
    const absolutePath = path.resolve(directoryToEmpty);
    trace(`emptying directory: ${absolutePath}`);
    if (!absolutePath.startsWith(process.cwd())) {
        throw new Error(`directoryToEmpty must be a child of the current working directory: ${directoryToEmpty}`);
    }
    if (absolutePath === process.cwd()) {
        throw new Error(`directoryToEmpty cannot be the current working directory: ${directoryToEmpty}`);
    }
    const dir = await fsp.opendir(directoryToEmpty, { encoding: 'utf-8' });
    if (mergedOptions.fileAndDirectoryNamesToSkip && !Array.isArray(mergedOptions.fileAndDirectoryNamesToSkip)) {
        throw new Error('fileAndDirectoryNamesToSkip must be an array');
    }
    let dirEntry = await dir.read();
    while (dirEntry) {
        if (mergedOptions.fileAndDirectoryNamesToSkip?.includes(dirEntry.name)) {
            dirEntry = await dir.read();
            continue;
        }
        const direntPath = path.join(directoryToEmpty, dirEntry.name);
        if (dirEntry.isDirectory()) {
            await fsp.rm(direntPath, { recursive: true, force: mergedOptions.force });
        }
        else {
            await fsp.rm(direntPath, { force: mergedOptions.force });
        }
        dirEntry = await dir.read();
    }
    await dir.close();
}
/**
 * Copies the contents of a directory to another directory (not including the top-level directory itself).
 *
 * If the destination directory does not exist, it will be created.
 * @param sourceDirectory Directory to copy from
 * @param destinationDirectory Directory to copy to
 */
export async function copyDirectoryContents(sourceDirectory, destinationDirectory) {
    requireString('sourceDirectory', sourceDirectory);
    requireString('destinationDirectory', destinationDirectory);
    if (!fs.existsSync(sourceDirectory)) {
        throw new Error(`sourceDirectory directory does not exist: ${sourceDirectory}`);
    }
    if (!fs.lstatSync(sourceDirectory).isDirectory()) {
        throw new Error(`sourceDirectory is not a directory: ${sourceDirectory}`);
    }
    if (!fs.existsSync(destinationDirectory)) {
        await mkdirp(destinationDirectory);
    }
    if (!fs.lstatSync(destinationDirectory).isDirectory()) {
        throw new Error(`destinationDirectory is not a directory: ${destinationDirectory}`);
    }
    const dir = await fsp.opendir(sourceDirectory, { encoding: 'utf-8' });
    let dirEntry = await dir.read();
    while (dirEntry) {
        const sourcePath = path.join(sourceDirectory, dirEntry.name);
        const destPath = path.join(destinationDirectory, dirEntry.name);
        if (dirEntry.isDirectory()) {
            await copyDirectoryContents(sourcePath, destPath);
        }
        else {
            await fsp.copyFile(sourcePath, destPath);
        }
        dirEntry = await dir.read();
    }
}
/**
 * Helper method to validate that a non-falsy and non-empty value is provided for a parameter that should be a string.
 * @param paramName The name of the parameter to be used in the error message
 * @param paramValue The value of the parameter
 */
export function requireString(paramName, paramValue) {
    if (paramValue === undefined || paramValue === null || paramValue === '' || typeof paramValue !== 'string' || paramValue.trim() === '') {
        throw new Error(`Required param '${paramName}' is missing`);
    }
}
/**
 * Helper method to validate that the path actually exists for the provided value.
 * @param paramName The name of the parameter, for logging purposes
 * @param paramValue The value of the parameter
 */
export function requireValidPath(paramName, paramValue) {
    requireString(paramName, paramValue);
    if (!fs.existsSync(paramValue)) {
        throw new Error(`Invalid or nonexistent path provided for param '${paramName}': ${paramValue}`);
    }
}
/**
 * Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit.
 *
 * See https://docs.docker.com/compose/environment-variables/envvars/#compose_project_name.
 * @param projectName The string to validate
 * @returns `true` if it's a valid docker compose project name and `false` otherwise
 */
export function isDockerComposeProjectNameValid(projectName) {
    requireString('projectName', projectName);
    // Ensure first char is a lowercase letter or digit
    if (!/^[a-z0-9]/.test(projectName[0])) {
        return false;
    }
    // Ensure the rest of the chars are only lowercase letters, digits, dashes and underscores
    return /^[a-z0-9-_]+$/.test(projectName);
}
/**
 * For docker compose commands, see https://docs.docker.com/compose/reference/. For available options for this wrapper function, see {@link DockerComposeOptions}.
 *
 * The current working directory will be the directory of the {@link dockerComposePath} unless specified in the options. This ensures relative paths in the
 * docker compose file will be relative to itself by default.
 *
 * See {@link DockerComposeOptions.projectName} for info on where to locate your docker compose file and how to specify the docker project name.
 * @param dockerComposePath Path to docker-compose.yml
 * @param dockerComposeCommand The docker-compose command to run
 * @param options {@link DockerComposeOptions} to use, including additional arguments to pass to the docker compose command and the project name
 */
export async function spawnDockerCompose(dockerComposePath, dockerComposeCommand, options) {
    requireValidPath('dockerComposePath', dockerComposePath);
    requireString('dockerComposeCommand', dockerComposeCommand);
    if (options?.cwd) {
        requireValidPath('cwd', options.cwd);
    }
    if (options?.altEnvFilePath) {
        requireValidPath('altEnvFilePath', options.altEnvFilePath);
    }
    if (options?.projectName && !isDockerComposeProjectNameValid(options.projectName)) {
        throw new Error('Invalid docker compose project name specified for the projectName param. Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit.');
    }
    if (options?.profile && !/[a-zA-Z0-9][a-zA-Z0-9_.-]+/.test(options.profile)) {
        throw new Error('Invalid profile option - must match regex: [a-zA-Z0-9][a-zA-Z0-9_.-]+');
    }
    if (!await isDockerRunning()) {
        throw new Error('Docker is not running');
    }
    const defaultOptions = { args: [], attached: false, projectName: undefined, cwd: undefined };
    const mergedOptions = { ...defaultOptions, ...options };
    if (!options || options.useWslPrefix === undefined) {
        mergedOptions.useWslPrefix = config.useWslPrefixForDockerCommands;
    }
    const dockerComposeDir = path.dirname(dockerComposePath);
    const dockerComposeFilename = path.basename(dockerComposePath);
    if (!mergedOptions.cwd) {
        mergedOptions.cwd = dockerComposeDir;
    }
    let dockerComposePathResolved = mergedOptions.cwd ? path.resolve(dockerComposePath) : dockerComposeFilename;
    if (mergedOptions.useWslPrefix) {
        dockerComposePathResolved = toWslPath(dockerComposePathResolved);
    }
    let spawnArgs = ['compose', '-f', dockerComposePathResolved];
    if (mergedOptions.projectName) {
        spawnArgs.push('--project-name', mergedOptions.projectName);
    }
    if (mergedOptions.profile) {
        spawnArgs.push('--profile', mergedOptions.profile);
    }
    if (mergedOptions.altEnvFilePath) {
        spawnArgs.push('--env-file', mergedOptions.useWslPrefix ? toWslPath(mergedOptions.altEnvFilePath) : mergedOptions.altEnvFilePath);
    }
    spawnArgs.push(dockerComposeCommand);
    if (!mergedOptions.attached && dockerComposeCommandsThatSupportDetached.includes(dockerComposeCommand)) {
        spawnArgs.push('--detach');
    }
    if (mergedOptions.args) {
        spawnArgs = spawnArgs.concat(mergedOptions.args);
    }
    trace(`running command in ${mergedOptions.cwd}: docker ${spawnArgs.join(' ')}`);
    const longRunning = dockerComposeCommandsThatSupportDetached.includes(dockerComposeCommand) && options?.attached === true;
    trace(`docker compose command will be configured to use long running option: ${longRunning}`);
    const spawnOptions = {
        cwd: mergedOptions.cwd,
        shell: isPlatformWindows(),
        isLongRunning: longRunning
    };
    const spawnResult = mergedOptions.useWslPrefix ?
        await spawnAsyncInternal('wsl', ['docker', ...spawnArgs], spawnOptions) :
        await spawnAsyncInternal('docker', spawnArgs, spawnOptions);
    if (spawnResult.code !== 0) {
        throw new Error(`docker compose command failed with code ${spawnResult.code}`);
    }
}
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Does not return empty lines. Also see {@link stringToLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
export function stringToNonEmptyLines(str) {
    if (!str) {
        return [];
    }
    return str.split('\n').filter(line => line?.trim()).map(line => line.replace('\r', ''));
}
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Returns empty lines. Also see {@link stringToNonEmptyLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
export function stringToLines(str) {
    if (!str) {
        return [];
    }
    return str.split('\n').map(line => line.replace('\r', ''));
}
/**
 * Runs the requested command using NodeJS spawnSync wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export function simpleCmdSync(command, args, throwOnNonZero = true) {
    if (!isPlatformWindows()) {
        throw new Error('getCmdResult is only supported on Windows');
    }
    // Was previously spawning 'cmd' directly with params '/D', '/S', '/C' - but we may as well let NodeJS do the work of escaping args to work correctly with cmd
    return simpleSpawnSyncInternal(command, args, throwOnNonZero, true);
}
/**
 * Runs the requested command using {@link spawnAsync} wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnAsync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export async function simpleCmdAsync(command, args, throwOnNonZero = true) {
    if (!isPlatformWindows()) {
        throw new Error('getCmdResult is only supported on Windows');
    }
    // Was previously spawning 'cmd' directly with params '/D', '/S', '/C' - but we may as well let NodeJS do the work of escaping args to work correctly with cmd
    return await simpleSpawnAsyncInternal(command, args, throwOnNonZero, true);
}
/**
 * Runs the requested command using NodeJS spawnSync and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export function simpleSpawnSync(command, args, throwOnNonZero = true) {
    return simpleSpawnSyncInternal(command, args, throwOnNonZero);
}
/**
 * Runs the requested command using {@link spawnAsync} and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
export async function simpleSpawnAsync(command, args, throwOnNonZero = true) {
    return await simpleSpawnAsyncInternal(command, args, throwOnNonZero);
}
/**
 * @returns `true` if platform() is 'win32', `false` otherwise
 */
export function isPlatformWindows() {
    return platform() === 'win32';
}
/**
 *
 * @returns `true` if platform() is 'darwin', `false` otherwise
 */
export function isPlatformMac() {
    return platform() === 'darwin';
}
/**
 *
 * @returns `true` if {@link isPlatformWindows} and {@link isPlatformMac} are both `false, otherwise returns `true`
 */
export function isPlatformLinux() {
    return !isPlatformWindows() && !isPlatformMac();
}
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
export async function which(commandName) {
    return whichInternal(commandName, simpleCmdAsync, simpleSpawnAsync);
}
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
export function whichSync(commandName) {
    return whichInternal(commandName, simpleCmdSync, simpleSpawnSync);
}
/**
 * Uses {@link which} to determine if docker is installed. If the `which` call doesn't find docker and the platform
 * is Windows, then this will check the output of `wsl docker --version` to see if just the engine is installed.
 * @returns `true` if docker is installed, `false` otherwise
 */
export async function isDockerInstalled() {
    if ((await which('docker')).location) {
        return true;
    }
    if (isPlatformWindows()) {
        const result = await simpleSpawnAsync('wsl', ['docker', '--version']);
        return result.code === 0;
    }
    return false;
}
/**
 * Runs the `docker info` command and looks for "error during connect" in the output to determine if docker is running. If you
 * want to check if docker is installed, use {@link isDockerInstalled}.
 * @returns `true` if docker is installed and running, `false` otherwise
 */
export async function isDockerRunning() {
    try {
        const result = isPlatformWindows() ?
            await simpleSpawnAsync('wsl', ['docker', 'info']) :
            await simpleSpawnAsync('docker', ['info']);
        return result.code === 0 && !result.stdout.includes('error during connect');
    }
    catch (err) {
        return false;
    }
}
/**
 * Attempt to start the docker service if it isn't running. Whether it's running is determined by a call to {@link isDockerRunning}.
 *
 * Notes on docker startup command:
 * - May require entering a password
 * - On Windows with Docker Desktop it will run `Start-Process "C:\Program Files\Docker\Docker\Docker Desktop.exe"`
 * - On Windows without Docker Desktop it will run `wsl -u root -e sh -c "service docker start"`
 * - On Linux it will run `sudo systemctl start docker`
 * - Not currently supported on Mac
 *
 * @throws An {@link Error} If docker is not detected on the system.
 * @throws An {@link Error} if docker is detected as installed and not running but the system is not Windows or Linux.
 */
export async function ensureDockerRunning() {
    if (!await isDockerInstalled()) {
        throw new Error('Docker does not appear to be installed');
    }
    if (await isDockerRunning()) {
        return;
    }
    let command;
    let args;
    if (isPlatformWindows()) {
        if (!(await which('docker')).location) {
            command = 'wsl';
            args = ['-u', 'root', '-e', 'sh', '-c', '"service docker start"'];
        }
        else {
            command = 'powershell';
            args = getPowershellHackArgs(`Start-Process "C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe"`);
        }
    }
    else if (isPlatformLinux()) {
        command = 'sudo';
        args = ['systemctl', 'start', 'docker'];
    }
    else {
        throw new Error('Starting docker within ensureDockerRunning is only supported on Windows and Linux - you will have to start docker manually');
    }
    const result = await spawnAsync(command, args);
    if (result.code !== 0) {
        throw new Error('Unable to start docker - see error above');
    }
}
/**
 * Uses built-in NodeJS readline to ask a question and return the user's answer.
 * @param query The question to ask
 * @returns A Promise that resolves to the user's answer
 */
export function askQuestion(query) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise(resolve => rl.question(`\n${query}\n`, ans => {
        rl.close();
        resolve(ans);
    }));
}
/**
 * A simple CLI prompt using the built-in NodeJS readline functionality to ask for confirmation.
 * @param question The question to ask
 * @returns A Promise that resolves to true if the user answers 'y' or 'yes', false otherwise
 */
export function getConfirmation(question) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise((resolve) => {
        rl.question(`\n  ${Emoji.RedQuestion} ${question}\n  ${Emoji.RightArrow} Proceed? (yes/no): `, (answer) => {
            rl.close();
            const confirmed = answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes';
            log(confirmed ? `  ${Emoji.GreenCheck} Proceeding\n` : `  ${Emoji.RedX} Aborting\n`);
            resolve(confirmed);
        });
    });
}
/**
 * Example of using {@link getConfirmation}.
 */
export async function getConfirmationExample() {
    if (await getConfirmation('Do you even?')) {
        log('you do even');
    }
    else {
        log('you do not even');
    }
}
/**
 * Copy entries from a source .env file to a destination .env file for which the destination .env file does not already have entries.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a .env.template file to a root .env file.
 *
 * For copying root .env files to other locations, use {@link overwriteEnvFile}.
 * @param sourcePath The path to the source .env file such as a `.env.template` file (use {@link overwriteEnvFile} for copying root .env files to other locations)
 * @param destinationPath The path to the destination .env file, such as the root .env file
 */
export async function copyNewEnvValues(sourcePath, destinationPath) {
    await copyEnv(sourcePath, destinationPath, false);
}
/**
 * Copy entries from a source .env file to a destination .env file, overwriting any existing entries in the destination .env file.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a root .env file to additional locations (server, client, docker-compose directory, etc.)
 * throughout your solution so you only have to manage one .env file.
 *
 * Note that this does not delete any existing entries in the destination .env file, which is useful if you have additional entries in
 * the destination .env file that you don't want to overwrite.
 *
 * For copying .env.template files to root .env files, use {@link copyNewEnvValues}.
 * @param sourcePath The path to the source .env file such as a root .env file (use {@link copyNewEnvValues} for .env.template files)
 * @param destinationPath The path to the destination .env file
 * @param suppressAddKeysMessages If true, messages about adding missing keys will not be logged (useful if you're always calling {@link copyModifiedEnv} after this call)
 */
export async function overwriteEnvFile(sourcePath, destinationPath, suppressAddKeysMessages = false) {
    await copyEnv(sourcePath, destinationPath, true, suppressAddKeysMessages);
}
/**
 * Copy entries from a source .env file to a destination .env file, but only for the keys specified in keepKeys.
 * Will also modify entries in the destination .env file as specified in modifyEntries.
 * @param sourcePath The path to the source .env file
 * @param destinationPath The path to the destination .env file
 * @param keepKeys The keys to keep from the source .env file
 * @param modifyEntries The entries to modify in the destination .env file
 */
export async function copyModifiedEnv(sourcePath, destinationPath, keepKeys, modifyEntries) {
    requireValidPath('sourcePath', sourcePath);
    const destPathDir = path.dirname(destinationPath);
    if (!fs.existsSync(destPathDir)) {
        await ensureDirectory(destPathDir);
    }
    const sourceDict = getEnvAsDictionary(sourcePath);
    const newDict = filterDictionary(sourceDict, key => keepKeys.includes(key));
    if (modifyEntries && Object.keys(modifyEntries).length > 0) {
        for (const [key, value] of Object.entries(modifyEntries)) {
            newDict[key] = value;
        }
    }
    const newSortedDict = sortDictionaryByKeyAsc(newDict);
    const newEnvFileContent = dictionaryToEnvFileString(newSortedDict);
    await fsp.writeFile(destinationPath, newEnvFileContent);
}
/**
 * Filters a dictionary by key.
 * @param dict The dictionary to filter
 * @param predicate A function that returns true if the key should be included in the filtered dictionary
 * @returns A new dictionary with only the keys that passed the predicate
 */
export function filterDictionary(dict, predicate) {
    // Notes to self:
    // - The second param of reduce is the initial value of the accumulator
    // - Reduce processes each element of the array and returns the accumulator for the next iteration
    // - In our case, the accumulator is a new dictionary that we're building up
    return Object.keys(dict)
        .filter(predicate)
        .reduce((accumulator, key) => {
        accumulator[key] = dict[key];
        return accumulator;
    }, {});
}
/**
 * Sorts a dictionary by key in ascending order.
 * @param dict The dictionary to sort
 * @returns A new dictionary sorted by key in ascending order
 */
export function sortDictionaryByKeyAsc(dict) {
    const newSortedDict = Object.entries(dict).sort((a, b) => {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    });
    return Object.fromEntries(newSortedDict);
}
/**
 * Helper method to delete a .env file if it exists.
 * @param envPath The path to the .env file to delete
 */
export async function deleteEnvIfExists(envPath) {
    // Just protecting ourselves from accidentally deleting something we didn't mean to
    if (envPath.endsWith('.env') === false) {
        throw new Error(`envPath must end with '.env': ${envPath}`);
    }
    // Using fsp.unlink will throw an error if it's a directory
    if (fs.existsSync(envPath)) {
        await fsp.unlink(envPath);
    }
}
/**
 * Searches a directory recursively for files that match the specified pattern.
 * The filenamePattern is a simple text string with asterisks (*) for wildcards.
 * @param dir The directory to find files in
 * @param filenamePattern The pattern to match files against
 * @param options Specify a max depth to search, defaults to 5
 * @returns A Promise that resolves to an array of file paths that match the pattern
 */
export async function findFilesRecursively(dir, filenamePattern, options) {
    validateFindFilesRecursivelyParams(dir, filenamePattern);
    const defaultOptions = { maxDepth: 5, excludeDirectoryNames: [], returnForwardSlashRelativePaths: false };
    const mergedOptions = { ...defaultOptions, ...options };
    // Convert the pattern to a regex
    const regex = new RegExp('^' + filenamePattern.split(/\*+/).map(escapeStringForRegex).join('.*') + '$');
    const matches = [];
    // Recursive function to search within directories
    async function searchDirectory(directory, depth) {
        if (depth > mergedOptions.maxDepth)
            return;
        const entries = await fsp.readdir(directory, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = resolve(directory, entry.name);
            if (entry.isDirectory()) {
                // Check if directory is in the exclude list
                if (!mergedOptions.excludeDirectoryNames?.includes(entry.name)) {
                    await searchDirectory(fullPath, depth + 1);
                }
            }
            else if (entry.isFile() && regex.test(entry.name)) {
                if (mergedOptions.returnForwardSlashRelativePaths) {
                    matches.push(path.relative(dir, fullPath).replace(/\\/g, '/'));
                }
                else {
                    matches.push(fullPath);
                }
            }
        }
    }
    await searchDirectory(dir, 1); // Start search from the first depth
    return matches;
}
/** Utility function to escape a string for use within regex */
export function escapeStringForRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
/**
 * Logs the provided 2-dimensional string array as a formatted table.
 *
 * @param data 2-dimensional string array where the first row is the column headers
 * @example
 *
 * logTable([
 *   ['Name', 'Age', 'Country'],
 *   ['Alice', '28', 'USA'],
 *   ['Bob', '22', 'Canada']
 * ])
 */
export function logTable(data) {
    if (data.length === 0 || data[0].length === 0)
        return;
    const numColumns = data[0].length;
    const columnWidths = [];
    for (let i = 0; i < numColumns; i++) {
        columnWidths[i] = Math.max(...data.map(row => row[i]?.length || 0));
    }
    const lineSeparator = columnWidths.map(width => '-'.repeat(width)).join(' + ');
    for (let i = 0; i < data.length; i++) {
        const paddedRowArray = data[i].map((cell, colIdx) => cell.padEnd(columnWidths[colIdx], ' '));
        log(paddedRowArray.join(' | '));
        if (i === 0)
            log(lineSeparator);
    }
}
/**
 * See {@link getPowershellHackArgs}.
 */
export const powershellHackPrefix = `$env:PSModulePath = [Environment]::GetEnvironmentVariable('PSModulePath', 'Machine'); `;
/**
 * Powershell doesn't load the system PSModulePath when running in a non-interactive shell.
 * This is a workaround to set the PSModulePath environment variable to the system value before running a powershell command.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The powershell command to run
 * @returns An array of arguments to pass to {@link spawnAsync} with the "powershell" command as the first argument
 */
export function getPowershellHackArgs(command) {
    return ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', `${powershellHackPrefix}${command}`];
}
/**
 * Returns a humanized string representation of the number of milliseconds using ms, seconds, minutes, or hours.
 * @param milliseconds The number of milliseconds to humanize
 * @returns A humanized string representation of the number
 */
export function humanizeTime(milliseconds) {
    let value;
    let unit;
    if (milliseconds < 1000) {
        return `${milliseconds} ms`;
    }
    if (milliseconds < 60000) {
        value = milliseconds / 1000;
        unit = 'second';
    }
    else if (milliseconds < 3600000) {
        value = milliseconds / 60000;
        unit = 'minute';
    }
    else {
        value = milliseconds / 3600000;
        unit = 'hour';
    }
    let stringValue = value.toFixed(2);
    if (stringValue.endsWith('.00')) {
        stringValue = stringValue.slice(0, -3);
    }
    else if (stringValue.endsWith('0')) {
        stringValue = stringValue.slice(0, -1);
    }
    if (stringValue !== '1') {
        unit += 's';
    }
    return `${stringValue} ${unit}`;
}
export class ExtendedError extends Error {
    innerError;
    constructor(message, innerError) {
        super(message);
        this.innerError = innerError ?? null;
        Object.setPrototypeOf(this, ExtendedError.prototype);
    }
}
export function getHostname(url) {
    requireString('url', url);
    trace(`attempting to convert url to hostname: ${url}`);
    try {
        const encodedUrl = encodeURI(url);
        const parsedUrl = new URL(encodedUrl.startsWith('http') ? encodedUrl : 'https://' + encodedUrl);
        trace(`parsed url: ${parsedUrl}`);
        return parsedUrl.hostname;
    }
    catch (e) {
        throw new ExtendedError("Invalid URL", e);
    }
}
export async function isDirectory(path) {
    try {
        const stats = await fsp.stat(path);
        return stats.isDirectory();
    }
    catch (err) {
        trace('error checking idDirectory (returning false)', err);
        return false;
    }
}
export function isDirectorySync(path) {
    try {
        const stats = fs.statSync(path);
        return stats.isDirectory();
    }
    catch (err) {
        trace('error checking idDirectory (returning false)', err);
        return false;
    }
}
/**
 * This is a somewhat naive method but is useful if you rarely or never deal with unusual operating systems.
 * @returns `win`, `mac` or `linux`
 */
export function getPlatformCode() {
    if (isPlatformWindows()) {
        return 'win';
    }
    if (isPlatformMac()) {
        return 'mac';
    }
    if (isPlatformLinux()) {
        return 'linux';
    }
    throw new Error('unrecognized platform: ' + platform());
}
/**
 * Tries connecting to a port to see if it's being listened on or not. It's likely that this won't work in a lot of scenarios, so use it at your own risk.
 * @param port The port to check
 * @returns `true` if the port is available, `false` otherwise
 */
export async function isPortAvailable(port) {
    return new Promise((resolve) => {
        const tester = net.connect(port, '127.0.0.1');
        tester.on('connect', () => {
            tester.destroy();
            resolve(false); // port is in use
        });
        tester.on('error', (err) => {
            tester.destroy();
            if (err.code === 'ECONNREFUSED') {
                resolve(true); // port is available
            }
            else {
                resolve(false); // some other error occurred, assume port is in use
            }
        });
    });
}
/**
 * Returns the value for an environment variable or throws if it's undefined or null. Pass optional `throwOnEmpty` param to throw when the key exists but has an empty value.
 * @param varName The name of the environment variable to get.
 * @param throwOnEmpty Throw an error if key exists (not undefined or null) but is empty.
 * @returns
 */
export function getRequiredEnvVar(varName, throwOnEmpty = true) {
    requireString('varName', varName);
    const val = process.env[varName];
    if (val === undefined || val === null) {
        throw new Error(`Missing required environment variable: ${varName}`);
    }
    if (throwOnEmpty && val.trim() === '') {
        throw new Error(`Required environment variable is empty: ${varName}`);
    }
    return val;
}
export function getNormalizedError(err) {
    let lastErrorAsError;
    if (err === undefined || err === null) {
        lastErrorAsError = new Error('lastError was undefined or null');
    }
    else if (err instanceof Error) {
        lastErrorAsError = err;
    }
    else if (typeof err === 'string') {
        lastErrorAsError = new Error(err);
    }
    else if (err instanceof Object) {
        try {
            lastErrorAsError = new Error(JSON.stringify(err));
        }
        catch (jsonError) {
            lastErrorAsError = new Error('Object could not be serialized - could not normalize');
        }
    }
    else {
        lastErrorAsError = new Error(`Unknown error of type ${typeof err} - could not normalize`);
    }
    return lastErrorAsError;
}
/**
 * Call a function until it succeeds. Will stop after the number of calls specified by `maxCalls` param, or forever if -1 is passed.
 * @param func The function to call
 * @param maxCalls The maximum number of times to call the function before giving up. Pass -1 to retry forever.
 * @param delayMilliseconds The number of milliseconds to wait between calls
 * @param options Options for controlling the behavior of the retry. See {@link WithRetryOptions}.
 */
export async function withRetryAsync(func, maxCalls, delayMilliseconds, options) {
    let attemptNumber = 0;
    let lastError;
    const forever = maxCalls === -1;
    const defaultOptions = { initialDelayMilliseconds: 0, traceEnabled: false, logIntermediateErrors: false };
    const mergedOptions = { ...defaultOptions, ...options };
    const shouldLog = config.traceEnabled || mergedOptions.traceEnabled;
    const retryLog = shouldLog ? log : () => { };
    const funcName = mergedOptions.functionLabel ?? func.name ?? 'anonymous';
    if (mergedOptions.initialDelayMilliseconds > 0) {
        retryLog(`initialDelayMilliseconds set to ${mergedOptions.initialDelayMilliseconds} - waiting before first try`);
        await sleep(mergedOptions.initialDelayMilliseconds);
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
        attemptNumber++;
        retryLog(`calling ${funcName} - attempt number ${attemptNumber}`);
        try {
            await func();
            retryLog(`attempt ${attemptNumber} was successful`);
            break;
        }
        catch (err) {
            if (mergedOptions.logIntermediateErrors || shouldLog) {
                console.error(err);
            }
            lastError = err;
        }
        if (!forever && attemptNumber === maxCalls) {
            throw new ExtendedError(`Failed to run method with retry after ${maxCalls} attempts`, getNormalizedError(lastError));
        }
        retryLog(`attempt number ${attemptNumber} failed - waiting ${delayMilliseconds} milliseconds before trying again`);
        await sleep(delayMilliseconds);
    }
}
/**
 * Collapses each instance of consecutive whitespace characters into a single space.
 */
export function collapseWhitespace(str) {
    return str.replace(/\s+/g, ' ');
}
/**
 * Check if a string is a valid directory name. This is a very simple check that just makes sure the string doesn't contain any invalid characters.
 * @param dirName The directory name to check
 * @returns `true` if the directory name is valid, `false` otherwise
 */
export function isValidDirName(dirName) {
    // List of generally invalid characters for directory names in Windows, macOS, and Linux
    const invalidChars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*'];
    for (const char of dirName) {
        if (invalidChars.includes(char) || char.charCodeAt(0) <= 31) {
            return false;
        }
    }
    return true;
}
export function hasWhitespace(str) {
    return /\s/.test(str);
}
export function stripShellMetaCharacters(input) {
    const metaCharacters = [
        '\\', '`', '$', '"', "'", '<', '>', '|', ';', ' ',
        '&', '(', ')', '[', ']', '{', '}', '?', '*', '#', '~', '^'
    ];
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`[${metaCharacters.map(escapeRegex).join('')}]`, 'g');
    return input.replace(regex, '');
}
export var Emoji;
(function (Emoji) {
    Emoji["RightArrow"] = "\u27A1\uFE0F";
    Emoji["LeftArrow"] = "\u2B05\uFE0F";
    Emoji["GreenCheck"] = "\u2705";
    Emoji["Warning"] = "\u26A0\uFE0F";
    Emoji["Lightning"] = "\u26A1";
    Emoji["Exclamation"] = "\u2757";
    Emoji["RedQuestion"] = "\u2753";
    Emoji["RedX"] = "\u274C";
    Emoji["Info"] = "\u2139\uFE0F";
    Emoji["SadFace"] = "\uD83D\uDE22";
    Emoji["Tools"] = "\uD83D\uDEE0\uFE0F";
    Emoji["NoEntry"] = "\u26D4";
    Emoji["Stop"] = "\uD83D\uDED1";
    Emoji["Certificate"] = "\uD83D\uDCDC";
    Emoji["Key"] = "\uD83D\uDD11";
})(Emoji || (Emoji = {}));
/**
 * Converts a windows path to a WSL path (Windows Subsystem for Linux) if it's an absolute path, otherwise returns it unchanged.
 *
 * Normally you can use `path.resolve()` to convert paths to whatever is appropriate for the OS, but if you're running on Windows and need to spawn a
 * command with `wsl yourCommand`, then you'll want to use this function to convert any parameters that are paths so that they can be resolved within WSL.
 * Because the intended use of this function is for passing params around, most use cases will also require paths with spaces or single quotes to be
 * wrapped in quotes, so `wrapInQuotesIfSpaces` defaults to true.
 * @param winPath The Windows path.
 * @param wrapInQuotesIfSpaces Defaults to `true`. If `true` and the `winPath` passed has spaces, the returned string will be wrapped in quotes.
 * Single quotes will be used unless there are single quote characters within the path, in which case it will be wrapped in double quotes.
 * @returns The wsl equivalent path.
 */
export function toWslPath(winPath, wrapInQuotesIfSpaces = true) {
    if (!path.isAbsolute(winPath)) {
        return winPath;
    }
    const drive = winPath.charAt(0).toLowerCase();
    const remainingPath = winPath.substring(2).replace(/\\/g, '/').replace(/\/{2,}/g, '/');
    const wslPath = path.posix.join(`/mnt/${drive}`, remainingPath);
    if (!wrapInQuotesIfSpaces) {
        return wslPath;
    }
    if (wslPath.includes("'")) {
        return `"${wslPath}"`;
    }
    if (wslPath.includes(' ')) {
        return `'${wslPath}'`;
    }
    return wslPath;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhbFV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2dlbmVyYWxVdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFDQSxPQUFPLEVBQUUsTUFBTSxTQUFTLENBQUE7QUFDeEIsT0FBTyxHQUFHLE1BQU0sa0JBQWtCLENBQUE7QUFDbEMsT0FBTyxFQUFFLFFBQVEsRUFBRSxNQUFNLFNBQVMsQ0FBQTtBQUNsQyxPQUFPLElBQUksRUFBRSxFQUFFLE9BQU8sRUFBRSxNQUFNLFdBQVcsQ0FBQTtBQUN6QyxPQUFPLEtBQUssUUFBUSxNQUFNLFVBQVUsQ0FBQTtBQUNwQyxPQUFPLEtBQUssR0FBRyxNQUFNLEtBQUssQ0FBQTtBQUMxQixPQUFPLEVBQUUsTUFBTSxFQUFFLE1BQU0seUJBQXlCLENBQUE7QUFDaEQsT0FBTyxFQUF3QixPQUFPLEVBQUUseUJBQXlCLEVBQUUsa0JBQWtCLEVBQUUsd0JBQXdCLEVBQUUsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUUsa0NBQWtDLEVBQUUsYUFBYSxFQUFFLE1BQU0sMkJBQTJCLENBQUE7QUFNbFAsTUFBTSx3Q0FBd0MsR0FBRyxDQUFDLE1BQU0sRUFBRSxNQUFNLEVBQUUsSUFBSSxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQTtBQUVoSDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLEdBQUcsQ0FBQyxJQUFhLEVBQUUsR0FBRyxRQUFtQjtJQUN2RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFBO0FBQ2hDLENBQUM7QUFFRDs7OztHQUlHO0FBQ0gsTUFBTSxVQUFVLEtBQUssQ0FBQyxTQUFrQixFQUFFLElBQWEsRUFBRSxHQUFHLFFBQW1CO0lBQzdFLElBQUksU0FBUyxFQUFFO1FBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxJQUFJLEVBQUUsR0FBRyxRQUFRLENBQUMsQ0FBQTtL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