import fs from 'node:fs';
import { mkdirp, spawnAsync, whichSync } from './generalUtils.js';
export interface CreateTarballOptions {
    /**
     * A list of files or directories to exclude from the tarball.
     * The paths should be relative to the directoryToTarball.
     */
    excludes?: string[];
}
export interface TarballUnpackOptions {
    createDirIfNotExists: boolean;
    stripComponents: number;
    throwOnNonEmptyUnpackDir: boolean;
}
export interface TarballUtilityDependencies {
    whichSyncFn: typeof whichSync;
    spawnAsyncFn: typeof spawnAsync;
    statSyncFn: typeof fs.statSync;
    mkdirpFn: typeof mkdirp;
}
/**
 * This utility class exists so we can mock the `which` dependency in unit tests without resorting to libraries that hack the import system.
 */
export declare class TarballUtility {
    private whichSyncFn;
    private spawnAsyncFn;
    private statSyncFn;
    private mkdirpFn;
    constructor(dependencies?: Partial<TarballUtilityDependencies>);
    /**
     * Creates a gzipped tarball from a directory by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
     * Note that Windows has tar since Windows 10 1803 (see https://devblogs.microsoft.com/commandline/windows10v1803/.
     *
     * It's possible this isn't 100% reliable due to differences in `tar` versions across platforms. If better normalization
     * is required, consider using the npm package `node-tar` instead.
     * @param directoryToTarball The directory to tarball. The directory name will be used as the root directory in the tarball
     * @param tarballPath The path to the tarball to create - must end with '.tar.gz'
     * @param options See {@link CreateTarballOptions}
     */
    createTarball: (directoryToTarball: string, tarballPath: string, options?: CreateTarballOptions) => Promise<void>;
    /**
     * Unpacks a gzipped tarball by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
     * This method will throw an error if the unpackDirectory is not empty, unless the `throwOnNonEmptyUnpackDir` option is set to false.
     * @param tarballPath The path to the tarball to unpack
     * @param unpackDirectory The directory to unpack the tarball into
     * @param options The options to use when unpacking the tarball. See {@link TarballUnpackOptions}.
     */
    unpackTarball: (tarballPath: string, unpackDirectory: string, options?: Partial<TarballUnpackOptions>) => Promise<void>;
    /**
     * A more opinionated version of {@link unpackTarball} that assumes you want to create the directory and strip the first directory out of the unpacked files.
     * @param tarballPath The path to the tarball to unpack
     * @param unpackDirectory The directory to unpack the tarball into - will be created if it doesn't exist and will throw if it exists but is not empty
     * @param stripComponents The number of leading directories to strip out of the unpacked files, defaults to 1
     */
    unpackTarballContents: (tarballPath: string, unpackDirectory: string, stripComponents?: number) => Promise<void>;
    private isDirectory;
    private dirIsNotEmpty;
    private tryCreateDirectory;
}
export declare const createTarball: (directoryToTarball: string, tarballPath: string, options?: CreateTarballOptions) => Promise<void>;
export declare const unpackTarball: (tarballPath: string, unpackDirectory: string, options?: Partial<TarballUnpackOptions>) => Promise<void>;
export declare const unpackTarballContents: (tarballPath: string, unpackDirectory: string, stripComponents?: number) => Promise<void>;
//# sourceMappingURL=TarballUtility.d.ts.map