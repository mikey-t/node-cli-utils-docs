"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDirectorySync = exports.isDirectory = exports.getHostname = exports.ExtendedError = exports.humanizeTime = exports.getPowershellHackArgs = exports.powershellHackPrefix = exports.logTable = exports.escapeStringForRegex = exports.findFilesRecursively = exports.deleteEnvIfExists = exports.sortDictionaryByKeyAsc = exports.filterDictionary = exports.copyModifiedEnv = exports.overwriteEnvFile = exports.copyNewEnvValues = exports.getConfirmationExample = exports.getConfirmation = exports.askQuestion = exports.ensureDockerRunning = exports.isDockerRunning = exports.isDockerInstalled = exports.whichSync = exports.which = exports.isPlatformLinux = exports.isPlatformMac = exports.isPlatformWindows = exports.simpleSpawnAsync = exports.simpleSpawnSync = exports.simpleCmdAsync = exports.simpleCmdSync = exports.stringToLines = exports.stringToNonEmptyLines = exports.spawnDockerCompose = exports.isDockerComposeProjectNameValid = exports.requireValidPath = exports.requireString = exports.copyDirectoryContents = exports.emptyDirectory = exports.mkdirpSync = exports.mkdirp = exports.ensureDirectory = exports.spawnAsyncLongRunning = exports.spawnAsync = exports.sleep = exports.SimpleSpawnError = exports.SpawnError = exports.trace = exports.logIf = exports.log = void 0;
exports.toWslPath = exports.Emoji = exports.stripShellMetaCharacters = exports.hasWhitespace = exports.isValidDirName = exports.collapseWhitespace = exports.withRetryAsync = exports.getNormalizedError = exports.getRequiredEnvVar = exports.isPortAvailable = exports.getPlatformCode = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const promises_1 = __importDefault(require("node:fs/promises"));
const node_os_1 = require("node:os");
const node_path_1 = __importStar(require("node:path"));
const readline = __importStar(require("readline"));
const net = __importStar(require("net"));
const NodeCliUtilsConfig_js_1 = require("./NodeCliUtilsConfig.js");
const generalUtilsInternal_js_1 = require("./generalUtilsInternal.js");
const dockerComposeCommandsThatSupportDetached = ['exec', 'logs', 'ps', 'restart', 'run', 'start', 'stop', 'up'];
/**
 * Just a wrapper for console.log() to type less.
 * @param data The data to log
 * @param moreData More data to log
 */
function log(data, ...moreData) {
    console.log(data, ...moreData);
}
exports.log = log;
/**
 * Log conditionally. Useful for methods that have an option to either suppress output or to show it when it normally isn't.
 * @param data The data to log
 * @param moreData More data to log
 */
function logIf(shouldLog, data, ...moreData) {
    if (shouldLog) {
        console.log(data, ...moreData);
    }
}
exports.logIf = logIf;
/**
 * Wrapper for console.log() that is suppressed if NodeCliUtilsConfig.logEnabled is false.
 * @param data The data to log
 * @param moreData More data to log
 */
function trace(data, ...moreData) {
    if (NodeCliUtilsConfig_js_1.config.traceEnabled) {
        const prefix = `[TRACE]`;
        console.log(prefix, data, ...moreData);
    }
}
exports.trace = trace;
/**
 * Error throw by {@link spawnAsync} when the spawned process exits with a non-zero exit code and options.throwOnNonZero is true.
 *
 * Contains a {@link SpawnResult} with the exit code, stdout, stderr, and error (if any).
 */
class SpawnError extends Error {
    constructor(message, result) {
        super(message);
        this.result = result;
    }
}
exports.SpawnError = SpawnError;
/**
 * Error throw by {@link simpleSpawnSync} and {@link simpleCmdSync} when the spawned process exits with a non-zero exit code and throwOnNonZero param is true (the default).
 *
 * Contains a {@link SimpleSpawnResult} with the exit code, stdout, stderr, and error (if any) in addition to stdoutLines, which is stdout split into lines from stdout that weren't empty.
 */
class SimpleSpawnError extends Error {
    constructor(message, result) {
        super(message);
        this.result = result;
    }
}
exports.SimpleSpawnError = SimpleSpawnError;
/**
 * Sleeps for the specified number of milliseconds.
 * @param ms The number of milliseconds to sleep
 * @returns A Promise that resolves after the specified number of milliseconds
 */
async function sleep(ms) {
    return new Promise((resolve) => {
        setTimeout(resolve, ms);
    });
}
exports.sleep = sleep;
/**
 * This is a wrapper function for NodeJS spawn. Defaults stdio to inherit so that output is visible in the console,
 * but note that this means stdout and stderr will not be available in the returned SpawnResult. To hide the output
 * from the console but collect the stdout and stderr in the SpawnResult, use stdio: 'pipe'.
 *
 * When spawning long-running processes, use {@link spawnAsyncLongRunning} instead so that unexpected
 * termination of the parent process will not orphan the child process tree on windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param options The options to pass to the command
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
async function spawnAsync(command, args, options) {
    return (0, generalUtilsInternal_js_1.spawnAsyncInternal)(command, args !== null && args !== void 0 ? args : [], options);
}
exports.spawnAsync = spawnAsync;
/**
 * Use this alternate spawn wrapper instead of {@link spawnAsync} when spawning long-running processes to
 * avoid orphaned child process trees on Windows.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The command to spawn
 * @param args The arguments to pass to the command
 * @param cwd The current working directory to run the command from - defaults to process.cwd()
 * @returns A Promise that resolves to a {@link SpawnResult}
 */
async function spawnAsyncLongRunning(command, args, cwd) {
    return (0, generalUtilsInternal_js_1.spawnAsyncInternal)(command, args !== null && args !== void 0 ? args : [], { cwd: cwd, isLongRunning: true });
}
exports.spawnAsyncLongRunning = spawnAsyncLongRunning;
/**
 * Ensure the directory exists. Similar to `mkdir -p` (creates parent directories if they don't exist).
 * @param dir The directory to ensure exists. If it does not exist, it will be created.
 */
async function ensureDirectory(dir) {
    return await mkdirp(dir);
}
exports.ensureDirectory = ensureDirectory;
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
async function mkdirp(dir) {
    requireString('dir', dir);
    try {
        await promises_1.default.mkdir(dir, { recursive: true });
    }
    catch (err) {
        // Must catch and re-throw in order to get a stack trace: https://github.com/nodejs/node/issues/30944
        throw new ExtendedError('Error creating directory', getNormalizedError(err));
    }
}
exports.mkdirp = mkdirp;
/**
 * Create a directory. Will create parent directory structure if it don't exist. Similar to `mkdir -p`.
 * @param dir The directory to create.
 */
async function mkdirpSync(dir) {
    requireString('dir', dir);
    node_fs_1.default.mkdirSync(dir, { recursive: true });
}
exports.mkdirpSync = mkdirpSync;
/**
 * Empties a directory of all files and subdirectories. Optionally skips files and directories at the top level. For other
 * options, see {@link EmptyDirectoryOptions}.
 * @param directoryToEmpty The directory to empty.
 * @param options See {@link EmptyDirectoryOptions}.
 */
async function emptyDirectory(directoryToEmpty, options) {
    var _a;
    requireString('directoryToEmpty', directoryToEmpty);
    const defaultOptions = { fileAndDirectoryNamesToSkip: [], force: false, throwIfNotExists: false };
    const mergedOptions = { ...defaultOptions, ...options };
    if (!node_fs_1.default.existsSync(directoryToEmpty)) {
        if (mergedOptions.throwIfNotExists) {
            throw new Error('Directory does not exist and throwIfNotExists was set to true');
        }
        trace(`directoryToEmpty does not exist - creating directory ${directoryToEmpty}`);
        await mkdirp(directoryToEmpty);
        return;
    }
    if (!node_fs_1.default.lstatSync(directoryToEmpty).isDirectory()) {
        throw new Error(`directoryToEmpty is not a directory: ${directoryToEmpty}`);
    }
    // Add some guardrails to prevent accidentally emptying the wrong directory
    const absolutePath = node_path_1.default.resolve(directoryToEmpty);
    trace(`emptying directory: ${absolutePath}`);
    if (!absolutePath.startsWith(process.cwd())) {
        throw new Error(`directoryToEmpty must be a child of the current working directory: ${directoryToEmpty}`);
    }
    if (absolutePath === process.cwd()) {
        throw new Error(`directoryToEmpty cannot be the current working directory: ${directoryToEmpty}`);
    }
    const dir = await promises_1.default.opendir(directoryToEmpty, { encoding: 'utf-8' });
    if (mergedOptions.fileAndDirectoryNamesToSkip && !Array.isArray(mergedOptions.fileAndDirectoryNamesToSkip)) {
        throw new Error('fileAndDirectoryNamesToSkip must be an array');
    }
    let dirEntry = await dir.read();
    while (dirEntry) {
        if ((_a = mergedOptions.fileAndDirectoryNamesToSkip) === null || _a === void 0 ? void 0 : _a.includes(dirEntry.name)) {
            dirEntry = await dir.read();
            continue;
        }
        const direntPath = node_path_1.default.join(directoryToEmpty, dirEntry.name);
        if (dirEntry.isDirectory()) {
            await promises_1.default.rm(direntPath, { recursive: true, force: mergedOptions.force });
        }
        else {
            await promises_1.default.rm(direntPath, { force: mergedOptions.force });
        }
        dirEntry = await dir.read();
    }
    await dir.close();
}
exports.emptyDirectory = emptyDirectory;
/**
 * Copies the contents of a directory to another directory (not including the top-level directory itself).
 *
 * If the destination directory does not exist, it will be created.
 * @param sourceDirectory Directory to copy from
 * @param destinationDirectory Directory to copy to
 */
async function copyDirectoryContents(sourceDirectory, destinationDirectory) {
    requireString('sourceDirectory', sourceDirectory);
    requireString('destinationDirectory', destinationDirectory);
    if (!node_fs_1.default.existsSync(sourceDirectory)) {
        throw new Error(`sourceDirectory directory does not exist: ${sourceDirectory}`);
    }
    if (!node_fs_1.default.lstatSync(sourceDirectory).isDirectory()) {
        throw new Error(`sourceDirectory is not a directory: ${sourceDirectory}`);
    }
    if (!node_fs_1.default.existsSync(destinationDirectory)) {
        await mkdirp(destinationDirectory);
    }
    if (!node_fs_1.default.lstatSync(destinationDirectory).isDirectory()) {
        throw new Error(`destinationDirectory is not a directory: ${destinationDirectory}`);
    }
    const dir = await promises_1.default.opendir(sourceDirectory, { encoding: 'utf-8' });
    let dirEntry = await dir.read();
    while (dirEntry) {
        const sourcePath = node_path_1.default.join(sourceDirectory, dirEntry.name);
        const destPath = node_path_1.default.join(destinationDirectory, dirEntry.name);
        if (dirEntry.isDirectory()) {
            await copyDirectoryContents(sourcePath, destPath);
        }
        else {
            await promises_1.default.copyFile(sourcePath, destPath);
        }
        dirEntry = await dir.read();
    }
}
exports.copyDirectoryContents = copyDirectoryContents;
/**
 * Helper method to validate that a non-falsy and non-empty value is provided for a parameter that should be a string.
 * @param paramName The name of the parameter to be used in the error message
 * @param paramValue The value of the parameter
 */
function requireString(paramName, paramValue) {
    if (paramValue === undefined || paramValue === null || paramValue === '' || typeof paramValue !== 'string' || paramValue.trim() === '') {
        throw new Error(`Required param '${paramName}' is missing`);
    }
}
exports.requireString = requireString;
/**
 * Helper method to validate that the path actually exists for the provided value.
 * @param paramName The name of the parameter, for logging purposes
 * @param paramValue The value of the parameter
 */
function requireValidPath(paramName, paramValue) {
    requireString(paramName, paramValue);
    if (!node_fs_1.default.existsSync(paramValue)) {
        throw new Error(`Invalid or nonexistent path provided for param '${paramName}': ${paramValue}`);
    }
}
exports.requireValidPath = requireValidPath;
/**
 * Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit.
 *
 * See https://docs.docker.com/compose/environment-variables/envvars/#compose_project_name.
 * @param projectName The string to validate
 * @returns `true` if it's a valid docker compose project name and `false` otherwise
 */
function isDockerComposeProjectNameValid(projectName) {
    requireString('projectName', projectName);
    // Ensure first char is a lowercase letter or digit
    if (!/^[a-z0-9]/.test(projectName[0])) {
        return false;
    }
    // Ensure the rest of the chars are only lowercase letters, digits, dashes and underscores
    return /^[a-z0-9-_]+$/.test(projectName);
}
exports.isDockerComposeProjectNameValid = isDockerComposeProjectNameValid;
/**
 * For docker compose commands, see https://docs.docker.com/compose/reference/. For available options for this wrapper function, see {@link DockerComposeOptions}.
 *
 * The current working directory will be the directory of the {@link dockerComposePath} unless specified in the options. This ensures relative paths in the
 * docker compose file will be relative to itself by default.
 *
 * See {@link DockerComposeOptions.projectName} for info on where to locate your docker compose file and how to specify the docker project name.
 * @param dockerComposePath Path to docker-compose.yml
 * @param dockerComposeCommand The docker-compose command to run
 * @param options {@link DockerComposeOptions} to use, including additional arguments to pass to the docker compose command and the project name
 */
async function spawnDockerCompose(dockerComposePath, dockerComposeCommand, options) {
    requireValidPath('dockerComposePath', dockerComposePath);
    requireString('dockerComposeCommand', dockerComposeCommand);
    if (options === null || options === void 0 ? void 0 : options.cwd) {
        requireValidPath('cwd', options.cwd);
    }
    if (options === null || options === void 0 ? void 0 : options.altEnvFilePath) {
        requireValidPath('altEnvFilePath', options.altEnvFilePath);
    }
    if ((options === null || options === void 0 ? void 0 : options.projectName) && !isDockerComposeProjectNameValid(options.projectName)) {
        throw new Error('Invalid docker compose project name specified for the projectName param. Project names must contain only lowercase letters, decimal digits, dashes, and underscores, and must begin with a lowercase letter or decimal digit.');
    }
    if ((options === null || options === void 0 ? void 0 : options.profile) && !/[a-zA-Z0-9][a-zA-Z0-9_.-]+/.test(options.profile)) {
        throw new Error('Invalid profile option - must match regex: [a-zA-Z0-9][a-zA-Z0-9_.-]+');
    }
    if (!await isDockerRunning()) {
        throw new Error('Docker is not running');
    }
    const defaultOptions = { args: [], attached: false, projectName: undefined, cwd: undefined };
    const mergedOptions = { ...defaultOptions, ...options };
    if (!options || options.useWslPrefix === undefined) {
        mergedOptions.useWslPrefix = NodeCliUtilsConfig_js_1.config.useWslPrefixForDockerCommands;
    }
    const dockerComposeDir = node_path_1.default.dirname(dockerComposePath);
    const dockerComposeFilename = node_path_1.default.basename(dockerComposePath);
    if (!mergedOptions.cwd) {
        mergedOptions.cwd = dockerComposeDir;
    }
    let dockerComposePathResolved = mergedOptions.cwd ? node_path_1.default.resolve(dockerComposePath) : dockerComposeFilename;
    if (mergedOptions.useWslPrefix) {
        dockerComposePathResolved = toWslPath(dockerComposePathResolved);
    }
    let spawnArgs = ['compose', '-f', dockerComposePathResolved];
    if (mergedOptions.projectName) {
        spawnArgs.push('--project-name', mergedOptions.projectName);
    }
    if (mergedOptions.profile) {
        spawnArgs.push('--profile', mergedOptions.profile);
    }
    if (mergedOptions.altEnvFilePath) {
        spawnArgs.push('--env-file', mergedOptions.useWslPrefix ? toWslPath(mergedOptions.altEnvFilePath) : mergedOptions.altEnvFilePath);
    }
    spawnArgs.push(dockerComposeCommand);
    if (!mergedOptions.attached && dockerComposeCommandsThatSupportDetached.includes(dockerComposeCommand)) {
        spawnArgs.push('--detach');
    }
    if (mergedOptions.args) {
        spawnArgs = spawnArgs.concat(mergedOptions.args);
    }
    trace(`running command in ${mergedOptions.cwd}: docker ${spawnArgs.join(' ')}`);
    const longRunning = dockerComposeCommandsThatSupportDetached.includes(dockerComposeCommand) && (options === null || options === void 0 ? void 0 : options.attached) === true;
    trace(`docker compose command will be configured to use long running option: ${longRunning}`);
    const spawnOptions = {
        cwd: mergedOptions.cwd,
        shell: isPlatformWindows(),
        isLongRunning: longRunning
    };
    const spawnResult = mergedOptions.useWslPrefix ?
        await (0, generalUtilsInternal_js_1.spawnAsyncInternal)('wsl', ['docker', ...spawnArgs], spawnOptions) :
        await (0, generalUtilsInternal_js_1.spawnAsyncInternal)('docker', spawnArgs, spawnOptions);
    if (spawnResult.code !== 0) {
        throw new Error(`docker compose command failed with code ${spawnResult.code}`);
    }
}
exports.spawnDockerCompose = spawnDockerCompose;
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Does not return empty lines. Also see {@link stringToLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
function stringToNonEmptyLines(str) {
    if (!str) {
        return [];
    }
    return str.split('\n').filter(line => line === null || line === void 0 ? void 0 : line.trim()).map(line => line.replace('\r', ''));
}
exports.stringToNonEmptyLines = stringToNonEmptyLines;
/**
 * Splits a string into lines, removing `\n` and `\r` characters. Returns empty lines. Also see {@link stringToNonEmptyLines}.
 * @param str String to split into lines
 * @returns An array of lines from the string, with empty lines removed
 */
function stringToLines(str) {
    if (!str) {
        return [];
    }
    return str.split('\n').map(line => line.replace('\r', ''));
}
exports.stringToLines = stringToLines;
/**
 * Runs the requested command using NodeJS spawnSync wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
function simpleCmdSync(command, args, throwOnNonZero = true) {
    if (!isPlatformWindows()) {
        throw new Error('getCmdResult is only supported on Windows');
    }
    // Was previously spawning 'cmd' directly with params '/D', '/S', '/C' - but we may as well let NodeJS do the work of escaping args to work correctly with cmd
    return (0, generalUtilsInternal_js_1.simpleSpawnSyncInternal)(command, args, throwOnNonZero, true);
}
exports.simpleCmdSync = simpleCmdSync;
/**
 * Runs the requested command using {@link spawnAsync} wrapped in an outer Windows CMD.exe command and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that aren't Windows and CMD specific, use {@link simpleSpawnAsync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
async function simpleCmdAsync(command, args, throwOnNonZero = true) {
    if (!isPlatformWindows()) {
        throw new Error('getCmdResult is only supported on Windows');
    }
    // Was previously spawning 'cmd' directly with params '/D', '/S', '/C' - but we may as well let NodeJS do the work of escaping args to work correctly with cmd
    return await (0, generalUtilsInternal_js_1.simpleSpawnAsyncInternal)(command, args, throwOnNonZero, true);
}
exports.simpleCmdAsync = simpleCmdAsync;
/**
 * Runs the requested command using NodeJS spawnSync and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
function simpleSpawnSync(command, args, throwOnNonZero = true) {
    return (0, generalUtilsInternal_js_1.simpleSpawnSyncInternal)(command, args, throwOnNonZero);
}
exports.simpleSpawnSync = simpleSpawnSync;
/**
 * Runs the requested command using {@link spawnAsync} and returns the result with stdout split into lines.
 *
 * Use this for simple quick commands that don't require a lot of control.
 *
 * For commands that are Windows and CMD specific, use {@link simpleCmdSync}.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command Command to run
 * @param args Arguments to pass to the command
 * @returns An object with the status code, stdout, stderr, and error (if any)
 * @throws {@link SimpleSpawnError} if the command fails and throwOnNonZero is true
 */
async function simpleSpawnAsync(command, args, throwOnNonZero = true) {
    return await (0, generalUtilsInternal_js_1.simpleSpawnAsyncInternal)(command, args, throwOnNonZero);
}
exports.simpleSpawnAsync = simpleSpawnAsync;
/**
 * @returns `true` if platform() is 'win32', `false` otherwise
 */
function isPlatformWindows() {
    return (0, node_os_1.platform)() === 'win32';
}
exports.isPlatformWindows = isPlatformWindows;
/**
 *
 * @returns `true` if platform() is 'darwin', `false` otherwise
 */
function isPlatformMac() {
    return (0, node_os_1.platform)() === 'darwin';
}
exports.isPlatformMac = isPlatformMac;
/**
 *
 * @returns `true` if {@link isPlatformWindows} and {@link isPlatformMac} are both `false, otherwise returns `true`
 */
function isPlatformLinux() {
    return !isPlatformWindows() && !isPlatformMac();
}
exports.isPlatformLinux = isPlatformLinux;
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
async function which(commandName) {
    return (0, generalUtilsInternal_js_1.whichInternal)(commandName, simpleCmdAsync, simpleSpawnAsync);
}
exports.which = which;
/**
 * This is a cross-platform method to get the location of a system command. Useful for checking if software
 * is installed, where it's installed and whether there are multiple locations.
 * @param commandName The name of the command to find
 * @returns The location of the command, any additional locations, and an error if one occurred
 */
function whichSync(commandName) {
    return (0, generalUtilsInternal_js_1.whichInternal)(commandName, simpleCmdSync, simpleSpawnSync);
}
exports.whichSync = whichSync;
/**
 * Uses {@link which} to determine if docker is installed. If the `which` call doesn't find docker and the platform
 * is Windows, then this will check the output of `wsl docker --version` to see if just the engine is installed.
 * @returns `true` if docker is installed, `false` otherwise
 */
async function isDockerInstalled() {
    if ((await which('docker')).location) {
        return true;
    }
    if (isPlatformWindows()) {
        const result = await simpleSpawnAsync('wsl', ['docker', '--version']);
        return result.code === 0;
    }
    return false;
}
exports.isDockerInstalled = isDockerInstalled;
/**
 * Runs the `docker info` command and looks for "error during connect" in the output to determine if docker is running. If you
 * want to check if docker is installed, use {@link isDockerInstalled}.
 * @returns `true` if docker is installed and running, `false` otherwise
 */
async function isDockerRunning() {
    try {
        const result = isPlatformWindows() ?
            await simpleSpawnAsync('wsl', ['docker', 'info']) :
            await simpleSpawnAsync('docker', ['info']);
        return result.code === 0 && !result.stdout.includes('error during connect');
    }
    catch (err) {
        return false;
    }
}
exports.isDockerRunning = isDockerRunning;
/**
 * Attempt to start the docker service if it isn't running. Whether it's running is determined by a call to {@link isDockerRunning}.
 *
 * Notes on docker startup command:
 * - May require entering a password
 * - On Windows with Docker Desktop it will run `Start-Process "C:\Program Files\Docker\Docker\Docker Desktop.exe"`
 * - On Windows without Docker Desktop it will run `wsl -u root -e sh -c "service docker start"`
 * - On Linux it will run `sudo systemctl start docker`
 * - Not currently supported on Mac
 *
 * @throws An {@link Error} If docker is not detected on the system.
 * @throws An {@link Error} if docker is detected as installed and not running but the system is not Windows or Linux.
 */
async function ensureDockerRunning() {
    if (!await isDockerInstalled()) {
        throw new Error('Docker does not appear to be installed');
    }
    if (await isDockerRunning()) {
        return;
    }
    let command;
    let args;
    if (isPlatformWindows()) {
        if (!(await which('docker')).location) {
            command = 'wsl';
            args = ['-u', 'root', '-e', 'sh', '-c', '"service docker start"'];
        }
        else {
            command = 'powershell';
            args = getPowershellHackArgs(`Start-Process "C:\\Program Files\\Docker\\Docker\\Docker Desktop.exe"`);
        }
    }
    else if (isPlatformLinux()) {
        command = 'sudo';
        args = ['systemctl', 'start', 'docker'];
    }
    else {
        throw new Error('Starting docker within ensureDockerRunning is only supported on Windows and Linux - you will have to start docker manually');
    }
    const result = await spawnAsync(command, args);
    if (result.code !== 0) {
        throw new Error('Unable to start docker - see error above');
    }
}
exports.ensureDockerRunning = ensureDockerRunning;
/**
 * Uses built-in NodeJS readline to ask a question and return the user's answer.
 * @param query The question to ask
 * @returns A Promise that resolves to the user's answer
 */
function askQuestion(query) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise(resolve => rl.question(`\n${query}\n`, ans => {
        rl.close();
        resolve(ans);
    }));
}
exports.askQuestion = askQuestion;
/**
 * A simple CLI prompt using the built-in NodeJS readline functionality to ask for confirmation.
 * @param question The question to ask
 * @returns A Promise that resolves to true if the user answers 'y' or 'yes', false otherwise
 */
function getConfirmation(question) {
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
    });
    return new Promise((resolve) => {
        rl.question(`\n  ${Emoji.RedQuestion} ${question}\n  ${Emoji.RightArrow} Proceed? (yes/no): `, (answer) => {
            rl.close();
            const confirmed = answer.toLowerCase() === 'y' || answer.toLowerCase() === 'yes';
            log(confirmed ? `  ${Emoji.GreenCheck} Proceeding\n` : `  ${Emoji.RedX} Aborting\n`);
            resolve(confirmed);
        });
    });
}
exports.getConfirmation = getConfirmation;
/**
 * Example of using {@link getConfirmation}.
 */
async function getConfirmationExample() {
    if (await getConfirmation('Do you even?')) {
        log('you do even');
    }
    else {
        log('you do not even');
    }
}
exports.getConfirmationExample = getConfirmationExample;
/**
 * Copy entries from a source .env file to a destination .env file for which the destination .env file does not already have entries.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a .env.template file to a root .env file.
 *
 * For copying root .env files to other locations, use {@link overwriteEnvFile}.
 * @param sourcePath The path to the source .env file such as a `.env.template` file (use {@link overwriteEnvFile} for copying root .env files to other locations)
 * @param destinationPath The path to the destination .env file, such as the root .env file
 */
async function copyNewEnvValues(sourcePath, destinationPath) {
    await (0, generalUtilsInternal_js_1.copyEnv)(sourcePath, destinationPath, false);
}
exports.copyNewEnvValues = copyNewEnvValues;
/**
 * Copy entries from a source .env file to a destination .env file, overwriting any existing entries in the destination .env file.
 * If the destination .env file does not exist, it will be created and populated with the source .env file's values.
 *
 * This is useful for copying values from a root .env file to additional locations (server, client, docker-compose directory, etc.)
 * throughout your solution so you only have to manage one .env file.
 *
 * Note that this does not delete any existing entries in the destination .env file, which is useful if you have additional entries in
 * the destination .env file that you don't want to overwrite.
 *
 * For copying .env.template files to root .env files, use {@link copyNewEnvValues}.
 * @param sourcePath The path to the source .env file such as a root .env file (use {@link copyNewEnvValues} for .env.template files)
 * @param destinationPath The path to the destination .env file
 * @param suppressAddKeysMessages If true, messages about adding missing keys will not be logged (useful if you're always calling {@link copyModifiedEnv} after this call)
 */
async function overwriteEnvFile(sourcePath, destinationPath, suppressAddKeysMessages = false) {
    await (0, generalUtilsInternal_js_1.copyEnv)(sourcePath, destinationPath, true, suppressAddKeysMessages);
}
exports.overwriteEnvFile = overwriteEnvFile;
/**
 * Copy entries from a source .env file to a destination .env file, but only for the keys specified in keepKeys.
 * Will also modify entries in the destination .env file as specified in modifyEntries.
 * @param sourcePath The path to the source .env file
 * @param destinationPath The path to the destination .env file
 * @param keepKeys The keys to keep from the source .env file
 * @param modifyEntries The entries to modify in the destination .env file
 */
async function copyModifiedEnv(sourcePath, destinationPath, keepKeys, modifyEntries) {
    requireValidPath('sourcePath', sourcePath);
    const destPathDir = node_path_1.default.dirname(destinationPath);
    if (!node_fs_1.default.existsSync(destPathDir)) {
        await ensureDirectory(destPathDir);
    }
    const sourceDict = (0, generalUtilsInternal_js_1.getEnvAsDictionary)(sourcePath);
    const newDict = filterDictionary(sourceDict, key => keepKeys.includes(key));
    if (modifyEntries && Object.keys(modifyEntries).length > 0) {
        for (const [key, value] of Object.entries(modifyEntries)) {
            newDict[key] = value;
        }
    }
    const newSortedDict = sortDictionaryByKeyAsc(newDict);
    const newEnvFileContent = (0, generalUtilsInternal_js_1.dictionaryToEnvFileString)(newSortedDict);
    await promises_1.default.writeFile(destinationPath, newEnvFileContent);
}
exports.copyModifiedEnv = copyModifiedEnv;
/**
 * Filters a dictionary by key.
 * @param dict The dictionary to filter
 * @param predicate A function that returns true if the key should be included in the filtered dictionary
 * @returns A new dictionary with only the keys that passed the predicate
 */
function filterDictionary(dict, predicate) {
    // Notes to self:
    // - The second param of reduce is the initial value of the accumulator
    // - Reduce processes each element of the array and returns the accumulator for the next iteration
    // - In our case, the accumulator is a new dictionary that we're building up
    return Object.keys(dict)
        .filter(predicate)
        .reduce((accumulator, key) => {
        accumulator[key] = dict[key];
        return accumulator;
    }, {});
}
exports.filterDictionary = filterDictionary;
/**
 * Sorts a dictionary by key in ascending order.
 * @param dict The dictionary to sort
 * @returns A new dictionary sorted by key in ascending order
 */
function sortDictionaryByKeyAsc(dict) {
    const newSortedDict = Object.entries(dict).sort((a, b) => {
        if (a < b) {
            return -1;
        }
        if (a > b) {
            return 1;
        }
        return 0;
    });
    return Object.fromEntries(newSortedDict);
}
exports.sortDictionaryByKeyAsc = sortDictionaryByKeyAsc;
/**
 * Helper method to delete a .env file if it exists.
 * @param envPath The path to the .env file to delete
 */
async function deleteEnvIfExists(envPath) {
    // Just protecting ourselves from accidentally deleting something we didn't mean to
    if (envPath.endsWith('.env') === false) {
        throw new Error(`envPath must end with '.env': ${envPath}`);
    }
    // Using fsp.unlink will throw an error if it's a directory
    if (node_fs_1.default.existsSync(envPath)) {
        await promises_1.default.unlink(envPath);
    }
}
exports.deleteEnvIfExists = deleteEnvIfExists;
/**
 * Searches a directory recursively for files that match the specified pattern.
 * The filenamePattern is a simple text string with asterisks (*) for wildcards.
 * @param dir The directory to find files in
 * @param filenamePattern The pattern to match files against
 * @param options Specify a max depth to search, defaults to 5
 * @returns A Promise that resolves to an array of file paths that match the pattern
 */
async function findFilesRecursively(dir, filenamePattern, options) {
    (0, generalUtilsInternal_js_1.validateFindFilesRecursivelyParams)(dir, filenamePattern);
    const defaultOptions = { maxDepth: 5, excludeDirectoryNames: [], returnForwardSlashRelativePaths: false };
    const mergedOptions = { ...defaultOptions, ...options };
    // Convert the pattern to a regex
    const regex = new RegExp('^' + filenamePattern.split(/\*+/).map(escapeStringForRegex).join('.*') + '$');
    const matches = [];
    // Recursive function to search within directories
    async function searchDirectory(directory, depth) {
        var _a;
        if (depth > mergedOptions.maxDepth)
            return;
        const entries = await promises_1.default.readdir(directory, { withFileTypes: true });
        for (const entry of entries) {
            const fullPath = (0, node_path_1.resolve)(directory, entry.name);
            if (entry.isDirectory()) {
                // Check if directory is in the exclude list
                if (!((_a = mergedOptions.excludeDirectoryNames) === null || _a === void 0 ? void 0 : _a.includes(entry.name))) {
                    await searchDirectory(fullPath, depth + 1);
                }
            }
            else if (entry.isFile() && regex.test(entry.name)) {
                if (mergedOptions.returnForwardSlashRelativePaths) {
                    matches.push(node_path_1.default.relative(dir, fullPath).replace(/\\/g, '/'));
                }
                else {
                    matches.push(fullPath);
                }
            }
        }
    }
    await searchDirectory(dir, 1); // Start search from the first depth
    return matches;
}
exports.findFilesRecursively = findFilesRecursively;
/** Utility function to escape a string for use within regex */
function escapeStringForRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
exports.escapeStringForRegex = escapeStringForRegex;
/**
 * Logs the provided 2-dimensional string array as a formatted table.
 *
 * @param data 2-dimensional string array where the first row is the column headers
 * @example
 *
 * logTable([
 *   ['Name', 'Age', 'Country'],
 *   ['Alice', '28', 'USA'],
 *   ['Bob', '22', 'Canada']
 * ])
 */
function logTable(data) {
    if (data.length === 0 || data[0].length === 0)
        return;
    const numColumns = data[0].length;
    const columnWidths = [];
    for (let i = 0; i < numColumns; i++) {
        columnWidths[i] = Math.max(...data.map(row => { var _a; return ((_a = row[i]) === null || _a === void 0 ? void 0 : _a.length) || 0; }));
    }
    const lineSeparator = columnWidths.map(width => '-'.repeat(width)).join(' + ');
    for (let i = 0; i < data.length; i++) {
        const paddedRowArray = data[i].map((cell, colIdx) => cell.padEnd(columnWidths[colIdx], ' '));
        log(paddedRowArray.join(' | '));
        if (i === 0)
            log(lineSeparator);
    }
}
exports.logTable = logTable;
/**
 * See {@link getPowershellHackArgs}.
 */
exports.powershellHackPrefix = `$env:PSModulePath = [Environment]::GetEnvironmentVariable('PSModulePath', 'Machine'); `;
/**
 * Powershell doesn't load the system PSModulePath when running in a non-interactive shell.
 * This is a workaround to set the PSModulePath environment variable to the system value before running a powershell command.
 *
 * **Warning:** Do NOT use this for generating commands dynamically from user input as it could be used to execute arbitrary code.
 * This is meant solely for building up known commands that are not made up of unsanitized user input, and only at compile time.
 * See {@link winInstallCert} and {@link winUninstallCert} for examples of taking user input and inserting it safely into known commands.
 * @param command The powershell command to run
 * @returns An array of arguments to pass to {@link spawnAsync} with the "powershell" command as the first argument
 */
function getPowershellHackArgs(command) {
    return ['-NoProfile', '-ExecutionPolicy', 'Bypass', '-Command', `${exports.powershellHackPrefix}${command}`];
}
exports.getPowershellHackArgs = getPowershellHackArgs;
/**
 * Returns a humanized string representation of the number of milliseconds using ms, seconds, minutes, or hours.
 * @param milliseconds The number of milliseconds to humanize
 * @returns A humanized string representation of the number
 */
function humanizeTime(milliseconds) {
    let value;
    let unit;
    if (milliseconds < 1000) {
        return `${milliseconds} ms`;
    }
    if (milliseconds < 60000) {
        value = milliseconds / 1000;
        unit = 'second';
    }
    else if (milliseconds < 3600000) {
        value = milliseconds / 60000;
        unit = 'minute';
    }
    else {
        value = milliseconds / 3600000;
        unit = 'hour';
    }
    let stringValue = value.toFixed(2);
    if (stringValue.endsWith('.00')) {
        stringValue = stringValue.slice(0, -3);
    }
    else if (stringValue.endsWith('0')) {
        stringValue = stringValue.slice(0, -1);
    }
    if (stringValue !== '1') {
        unit += 's';
    }
    return `${stringValue} ${unit}`;
}
exports.humanizeTime = humanizeTime;
class ExtendedError extends Error {
    constructor(message, innerError) {
        super(message);
        this.innerError = innerError !== null && innerError !== void 0 ? innerError : null;
        Object.setPrototypeOf(this, ExtendedError.prototype);
    }
}
exports.ExtendedError = ExtendedError;
function getHostname(url) {
    requireString('url', url);
    trace(`attempting to convert url to hostname: ${url}`);
    try {
        const encodedUrl = encodeURI(url);
        const parsedUrl = new URL(encodedUrl.startsWith('http') ? encodedUrl : 'https://' + encodedUrl);
        trace(`parsed url: ${parsedUrl}`);
        return parsedUrl.hostname;
    }
    catch (e) {
        throw new ExtendedError("Invalid URL", e);
    }
}
exports.getHostname = getHostname;
async function isDirectory(path) {
    try {
        const stats = await promises_1.default.stat(path);
        return stats.isDirectory();
    }
    catch (err) {
        trace('error checking idDirectory (returning false)', err);
        return false;
    }
}
exports.isDirectory = isDirectory;
function isDirectorySync(path) {
    try {
        const stats = node_fs_1.default.statSync(path);
        return stats.isDirectory();
    }
    catch (err) {
        trace('error checking idDirectory (returning false)', err);
        return false;
    }
}
exports.isDirectorySync = isDirectorySync;
/**
 * This is a somewhat naive method but is useful if you rarely or never deal with unusual operating systems.
 * @returns `win`, `mac` or `linux`
 */
function getPlatformCode() {
    if (isPlatformWindows()) {
        return 'win';
    }
    if (isPlatformMac()) {
        return 'mac';
    }
    if (isPlatformLinux()) {
        return 'linux';
    }
    throw new Error('unrecognized platform: ' + (0, node_os_1.platform)());
}
exports.getPlatformCode = getPlatformCode;
/**
 * Tries connecting to a port to see if it's being listened on or not. It's likely that this won't work in a lot of scenarios, so use it at your own risk.
 * @param port The port to check
 * @returns `true` if the port is available, `false` otherwise
 */
async function isPortAvailable(port) {
    return new Promise((resolve) => {
        const tester = net.connect(port, '127.0.0.1');
        tester.on('connect', () => {
            tester.destroy();
            resolve(false); // port is in use
        });
        tester.on('error', (err) => {
            tester.destroy();
            if (err.code === 'ECONNREFUSED') {
                resolve(true); // port is available
            }
            else {
                resolve(false); // some other error occurred, assume port is in use
            }
        });
    });
}
exports.isPortAvailable = isPortAvailable;
/**
 * Returns the value for an environment variable or throws if it's undefined or null. Pass optional `throwOnEmpty` param to throw when the key exists but has an empty value.
 * @param varName The name of the environment variable to get.
 * @param throwOnEmpty Throw an error if key exists (not undefined or null) but is empty.
 * @returns
 */
function getRequiredEnvVar(varName, throwOnEmpty = true) {
    requireString('varName', varName);
    const val = process.env[varName];
    if (val === undefined || val === null) {
        throw new Error(`Missing required environment variable: ${varName}`);
    }
    if (throwOnEmpty && val.trim() === '') {
        throw new Error(`Required environment variable is empty: ${varName}`);
    }
    return val;
}
exports.getRequiredEnvVar = getRequiredEnvVar;
function getNormalizedError(err) {
    let lastErrorAsError;
    if (err === undefined || err === null) {
        lastErrorAsError = new Error('lastError was undefined or null');
    }
    else if (err instanceof Error) {
        lastErrorAsError = err;
    }
    else if (typeof err === 'string') {
        lastErrorAsError = new Error(err);
    }
    else if (err instanceof Object) {
        try {
            lastErrorAsError = new Error(JSON.stringify(err));
        }
        catch (jsonError) {
            lastErrorAsError = new Error('Object could not be serialized - could not normalize');
        }
    }
    else {
        lastErrorAsError = new Error(`Unknown error of type ${typeof err} - could not normalize`);
    }
    return lastErrorAsError;
}
exports.getNormalizedError = getNormalizedError;
/**
 * Call a function until it succeeds. Will stop after the number of calls specified by `maxCalls` param, or forever if -1 is passed.
 * @param func The function to call
 * @param maxCalls The maximum number of times to call the function before giving up. Pass -1 to retry forever.
 * @param delayMilliseconds The number of milliseconds to wait between calls
 * @param options Options for controlling the behavior of the retry. See {@link WithRetryOptions}.
 */
async function withRetryAsync(func, maxCalls, delayMilliseconds, options) {
    var _a, _b;
    let attemptNumber = 0;
    let lastError;
    const forever = maxCalls === -1;
    const defaultOptions = { initialDelayMilliseconds: 0, traceEnabled: false, logIntermediateErrors: false };
    const mergedOptions = { ...defaultOptions, ...options };
    const shouldLog = NodeCliUtilsConfig_js_1.config.traceEnabled || mergedOptions.traceEnabled;
    const retryLog = shouldLog ? log : () => { };
    const funcName = (_b = (_a = mergedOptions.functionLabel) !== null && _a !== void 0 ? _a : func.name) !== null && _b !== void 0 ? _b : 'anonymous';
    if (mergedOptions.initialDelayMilliseconds > 0) {
        retryLog(`initialDelayMilliseconds set to ${mergedOptions.initialDelayMilliseconds} - waiting before first try`);
        await sleep(mergedOptions.initialDelayMilliseconds);
    }
    // eslint-disable-next-line no-constant-condition
    while (true) {
        attemptNumber++;
        retryLog(`calling ${funcName} - attempt number ${attemptNumber}`);
        try {
            await func();
            retryLog(`attempt ${attemptNumber} was successful`);
            break;
        }
        catch (err) {
            if (mergedOptions.logIntermediateErrors || shouldLog) {
                console.error(err);
            }
            lastError = err;
        }
        if (!forever && attemptNumber === maxCalls) {
            throw new ExtendedError(`Failed to run method with retry after ${maxCalls} attempts`, getNormalizedError(lastError));
        }
        retryLog(`attempt number ${attemptNumber} failed - waiting ${delayMilliseconds} milliseconds before trying again`);
        await sleep(delayMilliseconds);
    }
}
exports.withRetryAsync = withRetryAsync;
/**
 * Collapses each instance of consecutive whitespace characters into a single space.
 */
function collapseWhitespace(str) {
    return str.replace(/\s+/g, ' ');
}
exports.collapseWhitespace = collapseWhitespace;
/**
 * Check if a string is a valid directory name. This is a very simple check that just makes sure the string doesn't contain any invalid characters.
 * @param dirName The directory name to check
 * @returns `true` if the directory name is valid, `false` otherwise
 */
function isValidDirName(dirName) {
    // List of generally invalid characters for directory names in Windows, macOS, and Linux
    const invalidChars = ['<', '>', ':', '"', '/', '\\', '|', '?', '*'];
    for (const char of dirName) {
        if (invalidChars.includes(char) || char.charCodeAt(0) <= 31) {
            return false;
        }
    }
    return true;
}
exports.isValidDirName = isValidDirName;
function hasWhitespace(str) {
    return /\s/.test(str);
}
exports.hasWhitespace = hasWhitespace;
function stripShellMetaCharacters(input) {
    const metaCharacters = [
        '\\', '`', '$', '"', "'", '<', '>', '|', ';', ' ',
        '&', '(', ')', '[', ']', '{', '}', '?', '*', '#', '~', '^'
    ];
    const escapeRegex = (str) => str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const regex = new RegExp(`[${metaCharacters.map(escapeRegex).join('')}]`, 'g');
    return input.replace(regex, '');
}
exports.stripShellMetaCharacters = stripShellMetaCharacters;
var Emoji;
(function (Emoji) {
    Emoji["RightArrow"] = "\u27A1\uFE0F";
    Emoji["LeftArrow"] = "\u2B05\uFE0F";
    Emoji["GreenCheck"] = "\u2705";
    Emoji["Warning"] = "\u26A0\uFE0F";
    Emoji["Lightning"] = "\u26A1";
    Emoji["Exclamation"] = "\u2757";
    Emoji["RedQuestion"] = "\u2753";
    Emoji["RedX"] = "\u274C";
    Emoji["Info"] = "\u2139\uFE0F";
    Emoji["SadFace"] = "\uD83D\uDE22";
    Emoji["Tools"] = "\uD83D\uDEE0\uFE0F";
    Emoji["NoEntry"] = "\u26D4";
    Emoji["Stop"] = "\uD83D\uDED1";
    Emoji["Certificate"] = "\uD83D\uDCDC";
    Emoji["Key"] = "\uD83D\uDD11";
})(Emoji || (exports.Emoji = Emoji = {}));
/**
 * Converts a windows path to a WSL path (Windows Subsystem for Linux) if it's an absolute path, otherwise returns it unchanged.
 *
 * Normally you can use `path.resolve()` to convert paths to whatever is appropriate for the OS, but if you're running on Windows and need to spawn a
 * command with `wsl yourCommand`, then you'll want to use this function to convert any parameters that are paths so that they can be resolved within WSL.
 * Because the intended use of this function is for passing params around, most use cases will also require paths with spaces or single quotes to be
 * wrapped in quotes, so `wrapInQuotesIfSpaces` defaults to true.
 * @param winPath The Windows path.
 * @param wrapInQuotesIfSpaces Defaults to `true`. If `true` and the `winPath` passed has spaces, the returned string will be wrapped in quotes.
 * Single quotes will be used unless there are single quote characters within the path, in which case it will be wrapped in double quotes.
 * @returns The wsl equivalent path.
 */
function toWslPath(winPath, wrapInQuotesIfSpaces = true) {
    if (!node_path_1.default.isAbsolute(winPath)) {
        return winPath;
    }
    const drive = winPath.charAt(0).toLowerCase();
    const remainingPath = winPath.substring(2).replace(/\\/g, '/').replace(/\/{2,}/g, '/');
    const wslPath = node_path_1.default.posix.join(`/mnt/${drive}`, remainingPath);
    if (!wrapInQuotesIfSpaces) {
        return wslPath;
    }
    if (wslPath.includes("'")) {
        return `"${wslPath}"`;
    }
    if (wslPath.includes(' ')) {
        return `'${wslPath}'`;
    }
    return wslPath;
}
exports.toWslPath = toWslPath;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhbFV0aWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2dlbmVyYWxVdGlscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxzREFBd0I7QUFDeEIsZ0VBQWtDO0FBQ2xDLHFDQUFrQztBQUNsQyx1REFBeUM7QUFDekMsbURBQW9DO0FBQ3BDLHlDQUEwQjtBQUMxQixtRUFBZ0Q7QUFDaEQsdUVBQWtQO0FBTWxQLE1BQU0sd0NBQXdDLEdBQUcsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQUUsSUFBSSxDQUFDLENBQUE7QUFFaEg7Ozs7R0FJRztBQUNILFNBQWdCLEdBQUcsQ0FBQyxJQUFhLEVBQUUsR0FBRyxRQUFtQjtJQUN2RCxPQUFPLENBQUMsR0FBRyxDQUFDLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFBO0FBQ2hDLENBQUM7QUFGRCxrQkFFQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixLQUFLLENBQUMsU0FBa0IsRUFBRSxJQUFhLEVBQUUsR0FBRyxRQUFtQjtJQUM3RSxJQUFJLFNBQVMsRUFBRTtRQUNiLE9BQU8sQ0FBQyxHQUFHLENBQUMsSUFBSSxFQUFFLEdBQUcsUUFBUSxDQUFDLENBQUE7S0FDL0I7QUFDSCxDQUFDO0FBSkQsc0JBSUM7QUFFRDs7OztHQUlHO0FBQ0gsU0FBZ0IsS0FBSyxDQUFDLElBQWMsRUFBRSxHQUFHLFFBQW1CO0lBQzFELElBQUksOEJBQU0sQ0FBQyxZQUFZLEVBQUU7UUFDdkIsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFBO1FBQ3hCLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxHQUFHLFFBQVEsQ0FBQyxDQUFBO0tBQ3ZDO0FBQ0gsQ0FBQztBQUxELHNCQUtDO0FBaUNEOzs7O0dBSUc7QUFDSCxNQUFh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