"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.unpackTarballContents = exports.unpackTarball = exports.createTarball = exports.TarballUtility = void 0;
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const generalUtils_js_1 = require("./generalUtils.js");
const NodeCliUtilsConfig_js_1 = require("./NodeCliUtilsConfig.js");
/**
 * This utility class exists so we can mock the `which` dependency in unit tests without resorting to libraries that hack the import system.
 */
class TarballUtility {
    constructor(dependencies = {}) {
        var _a, _b, _c, _d;
        /**
         * Creates a gzipped tarball from a directory by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
         * Note that Windows has tar since Windows 10 1803 (see https://devblogs.microsoft.com/commandline/windows10v1803/.
         *
         * It's possible this isn't 100% reliable due to differences in `tar` versions across platforms. If better normalization
         * is required, consider using the npm package `node-tar` instead.
         * @param directoryToTarball The directory to tarball. The directory name will be used as the root directory in the tarball
         * @param tarballPath The path to the tarball to create - must end with '.tar.gz'
         * @param options See {@link CreateTarballOptions}
         */
        this.createTarball = async (directoryToTarball, tarballPath, options) => {
            (0, generalUtils_js_1.requireValidPath)('directoryToTarball', directoryToTarball);
            (0, generalUtils_js_1.requireString)('tarballPath', tarballPath);
            const defaultOptions = { excludes: [] };
            const mergedOptions = { ...defaultOptions, ...options };
            if (!this.whichSyncFn('tar').location) {
                throw new Error('tar command not found - please install tar on your OS to use this method, or consider using the npm package node-tar instead');
            }
            if (tarballPath.endsWith('.tar.gz') === false) {
                throw new Error(`tarballPath must end with '.tar.gz': ${tarballPath}`);
            }
            const directoryToTarballParentDir = node_path_1.default.dirname(directoryToTarball);
            const directoryToTarballName = node_path_1.default.basename(directoryToTarball);
            const outputDirectory = node_path_1.default.dirname(tarballPath);
            if (!node_fs_1.default.existsSync(outputDirectory)) {
                (0, generalUtils_js_1.trace)(`tarballPath directory does not exist - creating '${outputDirectory}'`);
                await this.mkdirpFn(outputDirectory);
            }
            else if (node_fs_1.default.existsSync(tarballPath)) {
                throw new Error(`tarballPath already exists - delete, move or rename it first: ${tarballPath}`);
            }
            const excludesArgs = mergedOptions.excludes.length > 0 ? mergedOptions.excludes.map(exclude => `--exclude=${exclude}`) : [];
            const verboseFlag = NodeCliUtilsConfig_js_1.config.traceEnabled ? ['-v'] : [];
            const args = [...(verboseFlag), '-czf', tarballPath, '-C', directoryToTarballParentDir, ...excludesArgs, directoryToTarballName];
            const result = await this.spawnAsyncFn('tar', args);
            if (result.code !== 0) {
                throw new Error(`tar command failed with code ${result.code}`);
            }
            (0, generalUtils_js_1.trace)('tarball created: ' + tarballPath);
        };
        /**
         * Unpacks a gzipped tarball by spawning a process to run OS-installed `tar` to avoid pulling in npm package dependencies.
         * This method will throw an error if the unpackDirectory is not empty, unless the `throwOnNonEmptyUnpackDir` option is set to false.
         * @param tarballPath The path to the tarball to unpack
         * @param unpackDirectory The directory to unpack the tarball into
         * @param options The options to use when unpacking the tarball. See {@link TarballUnpackOptions}.
         */
        this.unpackTarball = async (tarballPath, unpackDirectory, options) => {
            (0, generalUtils_js_1.requireValidPath)('tarballPath', tarballPath);
            (0, generalUtils_js_1.requireString)('unpackDirectory', unpackDirectory);
            if (!this.whichSyncFn('tar').location) {
                throw new Error('tar command not found - please install tar on your OS to use this method, or consider using the npm package node-tar instead');
            }
            const defaultOptions = { createDirIfNotExists: false, stripComponents: 0, throwOnNonEmptyUnpackDir: true };
            const mergedOptions = { ...defaultOptions, ...options };
            if (mergedOptions.stripComponents < 0) {
                throw new Error('stripComponents must be greater than or equal to 0 if provided');
            }
            const unpackedDirExists = node_fs_1.default.existsSync(unpackDirectory);
            if (unpackedDirExists && !this.isDirectory(unpackDirectory)) {
                throw new Error(`unpackDirectory exists but is not a directory: ${unpackDirectory}`);
            }
            if (mergedOptions.createDirIfNotExists && !unpackedDirExists) {
                await this.tryCreateDirectory(unpackDirectory);
            }
            if (!mergedOptions.createDirIfNotExists && !unpackedDirExists) {
                throw new Error(`unpackDirectory does not exist: ${unpackDirectory}`);
            }
            if (mergedOptions.throwOnNonEmptyUnpackDir && this.dirIsNotEmpty(unpackDirectory)) {
                throw new Error(`unpackDirectory exists but is not empty: ${unpackDirectory}`);
            }
            const verboseFlag = NodeCliUtilsConfig_js_1.config.traceEnabled ? ['-v'] : [];
            const args = [...(verboseFlag), '-xzf', tarballPath, '-C', unpackDirectory, '--strip-components', mergedOptions.stripComponents.toString()];
            const result = await this.spawnAsyncFn('tar', args);
            if (result.code !== 0) {
                throw new Error(`tar command failed with code ${result.code}`);
            }
            (0, generalUtils_js_1.trace)(`tarball unpacked at ${unpackDirectory}`);
        };
        /**
         * A more opinionated version of {@link unpackTarball} that assumes you want to create the directory and strip the first directory out of the unpacked files.
         * @param tarballPath The path to the tarball to unpack
         * @param unpackDirectory The directory to unpack the tarball into - will be created if it doesn't exist and will throw if it exists but is not empty
         * @param stripComponents The number of leading directories to strip out of the unpacked files, defaults to 1
         */
        this.unpackTarballContents = async (tarballPath, unpackDirectory, stripComponents = 1) => {
            await this.unpackTarball(tarballPath, unpackDirectory, { stripComponents, createDirIfNotExists: true });
        };
        this.isDirectory = (path) => {
            try {
                const stats = this.statSyncFn(path);
                return stats.isDirectory();
            }
            catch (err) {
                (0, generalUtils_js_1.trace)('error checking idDirectory (returning false)', err);
                return false;
            }
        };
        this.dirIsNotEmpty = (dirPath) => {
            try {
                const stats = this.statSyncFn(dirPath);
                return stats.isDirectory() && node_fs_1.default.readdirSync(dirPath).length > 0;
            }
            catch (err) {
                throw new generalUtils_js_1.ExtendedError('Error checking dirIsNotEmpty - see innerError', err);
            }
        };
        this.tryCreateDirectory = async (dirPath) => {
            try {
                await this.mkdirpFn(dirPath);
            }
            catch (err) {
                throw new generalUtils_js_1.ExtendedError('Error creating unpackDirectory - see innerError', err);
            }
        };
        this.whichSyncFn = (_a = dependencies.whichSyncFn) !== null && _a !== void 0 ? _a : generalUtils_js_1.whichSync;
        this.spawnAsyncFn = (_b = dependencies.spawnAsyncFn) !== null && _b !== void 0 ? _b : generalUtils_js_1.spawnAsync;
        this.statSyncFn = (_c = dependencies.statSyncFn) !== null && _c !== void 0 ? _c : node_fs_1.default.statSync;
        this.mkdirpFn = (_d = dependencies.mkdirpFn) !== null && _d !== void 0 ? _d : generalUtils_js_1.mkdirp;
    }
}
exports.TarballUtility = TarballUtility;
const defaultUtil = new TarballUtility();
exports.createTarball = defaultUtil.createTarball;
exports.unpackTarball = defaultUtil.unpackTarball;
exports.unpackTarballContents = defaultUtil.unpackTarballContents;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVGFyYmFsbFV0aWxpdHkuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvVGFyYmFsbFV0aWxpdHkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsc0RBQXdCO0FBQ3hCLDBEQUE0QjtBQUM1Qix1REFBd0g7QUFDeEgsbUVBQWdEO0FBdUJoRDs7R0FFRztBQUNILE1BQWEsY0FBYztJQU16QixZQUFZLGVBQW9ELEVBQUU7O1FBT2xFOzs7Ozs7Ozs7V0FTRztRQUNILGtCQUFhLEdBQUcsS0FBSyxFQUFFLGtCQUEwQixFQUFFLFdBQW1CLEVBQUUsT0FBOEIsRUFBRSxFQUFFO1lBQ3hHLElBQUEsa0NBQWdCLEVBQUMsb0JBQW9CLEVBQUUsa0JBQWtCLENBQUMsQ0FBQTtZQUMxRCxJQUFBLCtCQUFhLEVBQUMsYUFBYSxFQUFFLFdBQVcsQ0FBQyxDQUFBO1lBRXpDLE1BQU0sY0FBYyxHQUFHLEVBQUUsUUFBUSxFQUFFLEVBQUUsRUFBRSxDQUFBO1lBQ3ZDLE1BQU0sYUFBYSxHQUFHLEVBQUUsR0FBRyxjQUFjLEVBQUUsR0FBRyxPQUFPLEVBQUUsQ0FBQTtZQUV2RCxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxLQUFLLENBQUMsQ0FBQyxRQUFRLEVBQUU7Z0JBQ3JDLE1BQU0sSUFBSSxLQUFLLENBQUMsOEhBQThILENBQUMsQ0FBQTthQUNoSjtZQUVELElBQUksV0FBVyxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxLQUFLLEVBQUU7Z0JBQzdDLE1BQU0sSUFBSSxLQUFLLENBQUMsd0NBQXdDLFdBQVcsRUFBRSxDQUFDLENBQUE7YUFDdkU7WUFFRCxNQUFNLDJCQUEyQixHQUFHLG1CQUFJLENBQUMsT0FBTyxDQUFDLGtCQUFrQixDQUFDLENBQUE7WUFDcEUsTUFBTSxzQkFBc0IsR0FBRyxtQkFBSSxDQUFDLFFBQVEsQ0FBQyxrQkFBa0IsQ0FBQyxDQUFBO1lBRWhFLE1BQU0sZUFBZSxHQUFHLG1CQUFJLENB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