"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.whichInternal = exports.simpleSpawnAsyncInternal = exports.simpleSpawnSyncInternal = exports.validateFindFilesRecursivelyParams = exports.spawnAsyncInternal = exports.dictionaryToEnvFileString = exports.getEnvAsDictionary = exports.copyEnv = void 0;
const node_child_process_1 = require("node:child_process");
const node_fs_1 = __importDefault(require("node:fs"));
const promises_1 = __importDefault(require("node:fs/promises"));
const node_path_1 = __importDefault(require("node:path"));
const NodeCliUtilsConfig_js_1 = require("./NodeCliUtilsConfig.js");
const generalUtils_js_1 = require("./generalUtils.js");
const isCommonJS = typeof require === "function" && typeof module === "object" && module.exports;
const isEsm = !isCommonJS;
const spawnWorkaroundScriptName = 'runWhileParentAlive.js';
const currentModuleDir = ''; // Lazy loaded in getCurrentModuleDir
async function copyEnv(sourcePath, destinationPath, overrideExistingDestinationValues = true, suppressAddKeysMessages = false) {
    (0, generalUtils_js_1.requireValidPath)('sourcePath', sourcePath);
    // If the destination .env file doesn't exist, just copy it and return
    if (!node_fs_1.default.existsSync(destinationPath)) {
        (0, generalUtils_js_1.log)(`creating ${destinationPath} from ${sourcePath}`);
        await promises_1.default.copyFile(sourcePath, destinationPath);
        return;
    }
    const sourceDict = getEnvAsDictionary(sourcePath);
    const destinationDict = getEnvAsDictionary(destinationPath);
    // Determine what keys are missing from destinationPath .env that are in sourcePath .env or .env.template
    const templateKeys = Object.keys(sourceDict);
    const destinationKeysBeforeChanging = Object.keys(destinationDict);
    const keysMissingInDestination = templateKeys.filter(envKey => !destinationKeysBeforeChanging.includes(envKey));
    if (keysMissingInDestination.length > 0) {
        if (!suppressAddKeysMessages) {
            (0, generalUtils_js_1.log)(`adding missing keys in ${destinationPath}: ${keysMissingInDestination.join(', ')}`);
        }
    }
    // For instances where both .env files have the same key, use the value from the source if
    // overrideExistingDestinationValues param is true, otherwise leave the value from the destination intact.
    const newDict = {};
    for (const [key, value] of Object.entries(overrideExistingDestinationValues ? sourceDict : destinationDict)) {
        newDict[key] = value;
    }
    // Add entries that the destination doesn't have yet
    for (const key of keysMissingInDestination) {
        newDict[key] = sourceDict[key];
    }
    const newSortedDict = (0, generalUtils_js_1.sortDictionaryByKeyAsc)(newDict);
    const newEnvFileContent = dictionaryToEnvFileString(newSortedDict);
    await promises_1.default.writeFile(destinationPath, newEnvFileContent);
}
exports.copyEnv = copyEnv;
function getEnvAsDictionary(envPath) {
    const dict = {};
    const lines = (0, generalUtils_js_1.stringToNonEmptyLines)(node_fs_1.default.readFileSync(envPath).toString());
    for (const line of lines) {
        if (line && line.indexOf('=') !== -1) {
            const parts = line.split('=');
            dict[parts[0].trim()] = parts[1].trim();
        }
    }
    return dict;
}
exports.getEnvAsDictionary = getEnvAsDictionary;
function dictionaryToEnvFileString(dict) {
    return Object.entries(dict).map(kvp => `${kvp[0]}=${kvp[1]}`).join('\n') + '\n';
}
exports.dictionaryToEnvFileString = dictionaryToEnvFileString;
async function spawnAsyncInternal(command, args, options) {
    const mergedOptions = setDefaultsAndMergeOptions(options);
    const logPrefix = `[${command} ${args.join(' ')}] `;
    // Windows has an issue where child processes are orphaned when using the shell option. This workaround will spawn
    // a "middle" process using the shell option to check whether parent process is still running at intervals and if not, kill the child process tree.
    const workaroundScriptPath = await getWorkaroundScriptPath(command, args, options);
    if (workaroundScriptPath) {
        return await spawnWithKeepaliveWorkaround(logPrefix, workaroundScriptPath, command, args, mergedOptions);
    }
    return new Promise((resolve, reject) => {
        var _a, _b;
        try {
            const result = getInitialSpawnResult();
            const child = (0, node_child_process_1.spawn)(command, args, mergedOptions);
            const childId = child.pid;
            if (childId === undefined) {
                throw new Error(`${logPrefix}ChildProcess pid is undefined - spawn failed`);
            }
            // This event will only be emitted when stdio is NOT set to 'inherit'
            (_a = child.stdout) === null || _a === void 0 ? void 0 : _a.on('data', (data) => {
                result.stdout += data.toString();
            });
            // This event will only be emitted when stdio is NOT set to 'inherit'
            (_b = child.stderr) === null || _b === void 0 ? void 0 : _b.on('data', (data) => {
                result.stderr += data.toString();
            });
            const listener = new SignalListener(child, logPrefix);
            child.on('exit', (code, signal) => {
                const signalMessage = signal ? ` with signal ${signal}` : '';
                (0, generalUtils_js_1.trace)(`${logPrefix}ChildProcess exited with code ${code}${signalMessage}`);
                result.code = getResultCode(code, mergedOptions.isLongRunning);
                child.removeAllListeners();
                listener.detach();
                if (mergedOptions.throwOnNonZero && result.code !== 0) {
                    reject(getSpawnError(result.code, result, mergedOptions));
                    return;
                }
                resolve(result);
            });
            child.on('error', (error) => {
                (0, generalUtils_js_1.trace)(`${logPrefix}ChildProcess emitted an error event: `, error);
            });
        }
        catch (err) {
            reject(err);
        }
    });
}
exports.spawnAsyncInternal = spawnAsyncInternal;
// If long running, ctrl+c will cause a null code, which we don't necessarily want to consider an error
function getResultCode(code, isLongRunning) {
    return (code === null && isLongRunning) ? 0 : code !== null && code !== void 0 ? code : 1;
}
const setDefaultsAndMergeOptions = (options) => {
    const defaultSpawnOptions = { stdio: 'inherit', isLongRunning: false, throwOnNonZero: false };
    return { ...defaultSpawnOptions, ...options };
};
// Return workaroundScriptPath if:
// - Long running option set to true
// - OS is Windows
// - It's not the long running workaround call itself (avoid an infinite loop)
// Otherwise return undefined
async function getWorkaroundScriptPath(command, args, options) {
    var _a;
    const moduleDir = await getCurrentModuleDir();
    let workaroundScriptPath = node_path_1.default.join(moduleDir, spawnWorkaroundScriptName);
    // This allows use of spawnAsyncLongRunning within this project (i.e. swigfile.ts)
    if (!node_fs_1.default.existsSync(workaroundScriptPath) && workaroundScriptPath.includes('node-cli-utils')) {
        workaroundScriptPath = node_path_1.default.resolve('dist/esm', spawnWorkaroundScriptName);
    }
    if ((options === null || options === void 0 ? void 0 : options.isLongRunning) && (0, generalUtils_js_1.isPlatformWindows)() && !(command === 'node' && args && ((_a = args[0]) === null || _a === void 0 ? void 0 : _a.endsWith(spawnWorkaroundScriptName)))) {
        return workaroundScriptPath;
    }
    return undefined;
}
async function spawnWithKeepaliveWorkaround(logPrefix, workaroundScriptPath, command, args, options) {
    (0, generalUtils_js_1.trace)(`${logPrefix}Running on Windows with shell option - using middle process hack to prevent orphaned processes`);
    const loggingEnabledString = NodeCliUtilsConfig_js_1.config.orphanProtectionLoggingEnabled.toString();
    const traceEnabledString = NodeCliUtilsConfig_js_1.config.traceEnabled.toString();
    const pollingMillisString = NodeCliUtilsConfig_js_1.config.orphanProtectionPollingIntervalMillis.toString();
    (0, generalUtils_js_1.trace)(`${logPrefix}Orphan protection logging enabled: ${loggingEnabledString}`);
    (0, generalUtils_js_1.trace)(`${logPrefix}Orphan protection trace enabled: ${traceEnabledString}`);
    (0, generalUtils_js_1.trace)(`${logPrefix}Orphan protection polling interval: ${pollingMillisString}ms`);
    if (NodeCliUtilsConfig_js_1.config.orphanProtectionLoggingEnabled) {
        (0, generalUtils_js_1.trace)(`${logPrefix}Orphan protection logging path: ${NodeCliUtilsConfig_js_1.config.orphanProtectionLoggingPath}`);
    }
    const workaroundArgs = [
        workaroundScriptPath,
        loggingEnabledString,
        traceEnabledString,
        pollingMillisString,
        command,
        ...(args !== null && args !== void 0 ? args : [])
    ];
    return await (0, generalUtils_js_1.spawnAsync)('node', workaroundArgs, { ...options, stdio: 'inherit', shell: true });
}
function getInitialSpawnResult(options) {
    var _a, _b;
    return {
        code: 1,
        stdout: '',
        stderr: '',
        cwd: (_b = (_a = options === null || options === void 0 ? void 0 : options.cwd) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : process.cwd()
    };
}
function getSpawnError(code, result, options) {
    const additional = options.throwOnNonZero && options.stdio === 'inherit' ? `. See above for more details (stdio is 'inherit').` : '';
    return new generalUtils_js_1.SpawnError(`Spawning child process failed with code ${code}${additional}`, result);
}
class SignalListener {
    constructor(child, logPrefix) {
        this.signals = ['SIGINT', 'SIGTERM', 'SIGQUIT'];
        // Arrow function provides unique handler function for each instance of SignalListener
        this.handler = (signal) => {
            (0, generalUtils_js_1.trace)(`${this.logPrefix}Process received ${signal} - killing ChildProcess with ID ${this.child.pid}`);
            this.child.kill(signal);
            this.detach();
        };
        this.child = child;
        this.logPrefix = logPrefix;
        this.attach();
    }
    attach() {
        this.signals.forEach(signal => process.on(signal, this.handler));
    }
    detach() {
        this.signals.forEach(signal => process.removeListener(signal, this.handler));
    }
}
async function getCurrentModuleDir() {
    if (currentModuleDir) {
        return currentModuleDir;
    }
    if (isEsm) {
        const module = await Promise.resolve().then(() => __importStar(require('./esmSpecific.mjs')));
        const metaUrlFilePath = module.getImportMetaUrlFilePath();
        const directory = node_path_1.default.dirname(metaUrlFilePath);
        return node_path_1.default.normalize(directory);
    }
    return __dirname;
}
function validateFindFilesRecursivelyParams(dir, filenamePattern) {
    (0, generalUtils_js_1.requireValidPath)('dir', dir);
    (0, generalUtils_js_1.requireString)('pattern', filenamePattern);
    if (filenamePattern.length > 50) {
        throw new Error(`filenamePattern param must have fewer than 50 characters`);
    }
    const numWildcards = filenamePattern.replace(/\*+/g, '*').split('*').length - 1;
    if (numWildcards > 5) {
        throw new Error(`filenamePattern param must contain 5 or fewer wildcards`);
    }
    if (filenamePattern.includes('/') || filenamePattern.includes('\\')) {
        throw new Error('filenamePattern param must not contain slashes');
    }
}
exports.validateFindFilesRecursivelyParams = validateFindFilesRecursivelyParams;
function simpleSpawnSyncInternal(command, args, throwOnNonZero = true, useCmd = false) {
    var _a;
    (0, generalUtils_js_1.requireString)('command', command);
    const result = (0, node_child_process_1.spawnSync)(command, args !== null && args !== void 0 ? args : [], { encoding: 'utf-8', shell: useCmd ? 'cmd.exe' : false });
    const spawnResult = {
        code: (_a = result.status) !== null && _a !== void 0 ? _a : 1,
        stdout: result.stdout.toString(),
        stderr: result.stdout.toString(),
        stdoutLines: (0, generalUtils_js_1.stringToNonEmptyLines)(result.stdout.toString()),
        error: result.error,
        cwd: process.cwd()
    };
    if (spawnResult.code !== 0 && throwOnNonZero) {
        throw new generalUtils_js_1.SimpleSpawnError(`spawned process failed with code ${spawnResult.code}`, spawnResult);
    }
    return spawnResult;
}
exports.simpleSpawnSyncInternal = simpleSpawnSyncInternal;
async function simpleSpawnAsyncInternal(command, args, throwOnNonZero = true, useCmd = false) {
    (0, generalUtils_js_1.requireString)('command', command);
    const result = await (0, generalUtils_js_1.spawnAsync)(command, args, { stdio: 'pipe', shell: useCmd ? 'cmd.exe' : false });
    const spawnResult = {
        code: result.code,
        stdout: result.stdout,
        stderr: result.stdout,
        stdoutLines: (0, generalUtils_js_1.stringToNonEmptyLines)(result.stdout),
        error: result.error,
        cwd: process.cwd()
    };
    if (spawnResult.code !== 0 && throwOnNonZero) {
        throw new generalUtils_js_1.SimpleSpawnError(`spawned process failed with code ${spawnResult.code}`, spawnResult);
    }
    return spawnResult;
}
exports.simpleSpawnAsyncInternal = simpleSpawnAsyncInternal;
// Spawn functions passed here so they can be mocked in tests
function whichInternal(commandName, simpleCmd, simpleSpawn) {
    (0, generalUtils_js_1.requireString)('commandName', commandName);
    if ((0, generalUtils_js_1.stripShellMetaCharacters)(commandName) !== commandName) {
        throw new Error(`commandName cannot contain shell meta characters: ${commandName}`);
    }
    const execFunc = (0, generalUtils_js_1.isPlatformWindows)() ? simpleCmd : simpleSpawn;
    const cmd = (0, generalUtils_js_1.isPlatformWindows)() ? 'where' : 'which';
    const args = (0, generalUtils_js_1.isPlatformWindows)() ? [commandName] : ['-a', commandName];
    try {
        const result = execFunc(cmd, args);
        if (result instanceof Promise) {
            return result.then(parsedResult => ({
                location: parsedResult.stdoutLines[0],
                additionalLocations: parsedResult.stdoutLines.slice(1),
                error: parsedResult.error
            })).catch(err => ({
                location: undefined,
                additionalLocations: undefined,
                error: err
            }));
        }
        return {
            location: result.stdoutLines[0],
            additionalLocations: result.stdoutLines.slice(1),
            error: result.error
        };
    }
    catch (err) {
        return {
            location: undefined,
            additionalLocations: undefined,
            error: err
        };
    }
}
exports.whichInternal = whichInternal;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJhbFV0aWxzSW50ZXJuYWwuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvZ2VuZXJhbFV0aWxzSW50ZXJuYWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyREFBbUU7QUFDbkUsc0RBQXdCO0FBQ3hCLGdFQUFrQztBQUNsQywwREFBNEI7QUFDNUIsbUVBQWdEO0FBQ2hELHVEQUFnVDtBQUVoVCxNQUFNLFVBQVUsR0FBRyxPQUFPLE9BQU8sS0FBSyxVQUFVLElBQUksT0FBTyxNQUFNLEtBQUssUUFBUSxJQUFJLE1BQU0sQ0FBQyxPQUFPLENBQUE7QUFDaEcsTUFBTSxLQUFLLEdBQUcsQ0FBQyxVQUFVLENBQUE7QUFDekIsTUFBTSx5QkFBeUIsR0FBRyx3QkFBd0IsQ0FBQTtBQUMxRCxNQUFNLGdCQUFnQixHQUFXLEVBQUUsQ0FBQSxDQUFDLHFDQUFxQztBQUVsRSxLQUFLLFVBQVUsT0FBTyxDQUFDLFVBQWtCLEVBQUUsZUFBdUIsRUFBRSxpQ0FBaUMsR0FBRyxJQUFJLEVBQUUsdUJBQXVCLEdBQUcsS0FBSztJQUNsSixJQUFBLGtDQUFnQixFQUFDLFlBQVksRUFBRSxVQUFVLENBQUMsQ0FBQTtJQUUxQyxzRUFBc0U7SUFDdEUsSUFBSSxDQUFDLGlCQUFFLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxFQUFFO1FBQ25DLElBQUEscUJBQUcsRUFBQyxZQUFZLGVBQWUsU0FBUyxVQUFVLEVBQUUsQ0FBQyxDQUFBO1FBQ3JELE1BQU0sa0JBQUcsQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLGVBQWUsQ0FBQyxDQUFBO1FBQy9DLE9BQU07S0FDUDtJQUVELE1BQU0sVUFBVSxHQUFHLGtCQUFrQixDQUFDLFVBQVUsQ0FBQyxDQUFBO0lBQ2pELE1BQU0sZUFBZSxHQUFHLGtCQUFrQixDQUFDLGVBQWUsQ0FBQyxDQUFBO0lBRTNELHlHQUF5RztJQUN6RyxNQUFNLFlBQVks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